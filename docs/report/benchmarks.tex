%\documentclass[11pt]{article}\input{inc/style.sty}\begin{document}

\section{Benchmarks} \label{benchmarks}
In an attempt to provide realistic benchmarks, we tried to gather related implementations. The authors of \cite{gpu_atlp} did not respond to our multiple solicitations. The authors of \cite{swat_mega} were very friendly and provided us their source code. Unfortunately, since they address a different category of problem (they focus on huge serial problems whereas we focus on smaller non-serial problems) their implementation might be biased towards large sequences that our implementation cannot address. Finally, we asked lately the authors of \cite{gpu_rnafold} who did not respond either to our solicitations.

We organize the benchmarks as follow: if we have at our disposal a working implementation that could be run on our evaluation platform, we use it, otherwise, we refer to the related paper and rescale the result according to the memory throughput and computation throughput of the related device so that we can have a good approximation of how they could compare.

\subsection{Metrics} \label{metrics}
The main metrics of interest is the running time. In an attempt to reduce the variance, we would like to run multiple consecutive test and take the median running time, since the median is less sensitive to outlier than the average\cite{perfeval}. Unfortunately, several factors hampers these ideal conditions. First the variance in the running time of CUDA kernels might be significant, in particular for short running time. This is due to the fact that the GPU needs to be 'warmed-up' before actual computation can happen. Similarly, the JVM is also subject to running time variance that is mainly due to the garbage collection\footnote{\url{http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html\#cms.overhead}} and JIT optimizations \cite{java_jit}.

Also the input and problem might introduce variance. As example, we can consider two extreme cases: matrix chain multiplication and Zuker RNA folding, with a test environment of 100 random inputs (of length respectively 512 and 80) and a GPU warmup of 10 computations. In this settings, matrix chain multiplication computations are executed in a perfectly constant time\footnote{With respect to truncation and measurment accurcy, has less than 1\% of variation (not observable).} (0.127 seconds), which mean that we sufficiently reduced the noise. Oppositely, the Zuker RNA folding running times appear much more scattered as presented below:

\begin{figure}[H]\begin{center}\includegraphics[width=16cm]{inc/var_zuker.pdf}\end{center}
\caption{Zuker folding running time (seconds). Quartiles: 0.152, 0.183 (median), 0.214}\label{fig:var_zuker}\end{figure}

Using the QQplot\footnote{Quantile-to-quantile plot, used to compare two distributions against each other.}, the distribution is heavily tailed (has more results towards the ends of the range) than a Gaussian distribution (fig.~\ref{fig:var_zuker} center) but fits better an uniform distribution (fig.~\ref{fig:var_zuker} right). If we run multiple time the program over the same input, we obtain the same behavior as with the matrix multiplication (strictly identical time); hence we can conclude that Zuker is an input sensitive problem whereas matrix chain multiplication is not. It follows that we need to be careful to test with exactly identical input set different implementations.

As the device memory is quite limited, it seems interesting to also take into account the space usage. The space requirement limits the maximal size of addressable problems  on a particular hardware. This might be a concern for large problems, because they would require special adaptation to handle such cases both correctly and efficiently. However, this metric heavily depends on the problem and simple solutions like using a device with larger memory or using main memory (if a $5\times$ slowdown is still acceptable) could solve this issue, hence we do not consider this metric hereafter (except as an upper bound on the dimension of the input).

\subsection{Benchmarking platform}
Our benchmarking platform is an Apple notebook with a Core i7-3720QM with 16Gb of main memory and an NVIDIA GeForce GT 650M running under MacOS X 10.8 and Oracle JDK 1.7.0-10. A workaround (see listing~\ref{cpu_workaround}) allows us to use the CPU to render the user interface while leaving the graphic card available to execute CUDA kernels. Unfortunately, due to impossibility to disable the watchdog timer in MacOS, CUDA kernels are limited to few seconds of running time before they are automatically aborted.

% ----------------------------------------------
\def\hdr#1#2{\begin{minipage}{3.5cm} {\bf #1} \\[-2pt] \footnotesize #2 \vspace{6pt} \end{minipage}}
% ----------------------------------------------
% MatrixMult-512, Mac+JDK7
% -> Original: 24.658 sec
% -> Optimized concatenation: 18.924 sec
% -> Tabulation as arrays+inline: 14.849 sec
% -> Re-optimized concatenation: 10.76 sec
\newpage
\subsection{Matrix chain multiplication}
Since we have seen that this problem is not input sensitive in (\S\ref{metrics}), we can safely use different random number generators among different implementations without compromising the validity of the results.  Also note that the hand-optimized results are slightly worse than those presented in (\S\ref{baseline_impl}), this is because 64-bit mode is enabled. Because external libraries linked with the Java virtual machine must be in 64 bit, we also enabled this mode in hand-optimized version to maintain a fair comparison, thereby reducing the performance of CUDA operations.
% CPU: DynaProg(Scala), hand optimized C, GAPC and ADPFusion
% GPU: GPU: DynaProg(CUDA), hand optimized CUDA, ATLP and GAPC-OpenCL?

\begin{table}[H]\begin{center}{\small\begin{tabular}{llrrrrrrrr}\toprule
& \normalsize\bf Matrix dimension & \normalsize\bf 128 & \normalsize\bf 256 & \normalsize\bf 512 & \normalsize\bf 1024 & \normalsize\bf 2048 & \normalsize\bf 4096 & \normalsize\bf 8192 \\
\midrule \multirow{4}{*}{\rotatebox{90}{\normalsize\bf CPU $\quad$}}
& \hdr{DynaProg}{Scala version}
	& 0.167		& 1.377		& 10.760		& 86.966		& 712.688	&  			& 		 \\
& \hdr{Optimized}{C, single thread}
	& 0.001		& 0.008		& 0.078		& 1.179		& 19.811		& 206.556	& 2010.485 \\
& \hdr{GAPC}{\cite{gapc_thesis}, C, single thread}
	& 0.012		& 0.050		& 0.348		& 2.822		& 25.163		& 224.704	& 		 \\[-2pt]
\midrule \multirow{4}{*}{\rotatebox{90}{\normalsize\bf GPU $\quad$}}
& \hdr{DynaProg}{CUDA version}
	& 0.028		& 0.046		& 0.129		& 0.348		& 1.685		& 10.308		& 71.215 \\
& \hdr{Optimized}{CUDA, 64-bit}
	& 0.011		& 0.020		& 0.074		& 0.315		& 1.651		& 10.354		& 72.376 \\
% 32-bit &&		&			&			& 0.316		& 1.427		& 8.841		& 62.064
& \hdr{ATLP}{\cite{gpu_atlp}, rescaled results$^{(1)}$}
	& 0.170		& 0.199		& 0.227		& 0.397		& 1.335		& 7.299 		& --- \\
\bottomrule\end{tabular}}\end{center}\caption{Running time of matrix chain multiplication (in seconds)}\end{table}

$^{(1)}$ Assuming that 72\% of the running time is due to memory accesses, and considering a $3.55\times$ memory throughput slowdown (see \S\ref{results_discussion}). % 0.06 & 0.07 & 0.08 & 0.14 & 0.47 & 2.57 => f[x_] := (x*(1 - .72)) + (x*0.72)*(102.4/28.8)
% 0.1704 & 0.1988 & 0.2272 & .3976 & 1.3348 & 7.2988

The running time of DynaProg/CUDA includes the overhead of back and forth JNI conversion (scales linearly between 0.018 and 0.057 seconds) but does not include the overhead due to the code generation which decomposes in 0.068 seconds for analysis and code synthesis (once per algebra/grammar pair) and 0.086 + 1.753 seconds for respectively Scala and CUDA compilation (constant time, once per problem dimension).

For DynaProg/Scala we use a variant of the problem description: the original version only stores the matrix multiplication score whereas the modified version also stores the matrix dimension. This allows a speedup of $2.9\times$ probably due to additional function calls to retrieve the values. Also with the default JVM parameters, the program cannot address sequences longer than $\sim 420$ elements due to a stack overflow, for these benchmarks, we increased this limit	.

% ------------------------------------------------------------------------------------------------
{\center\color{red} \noindent\rule{16cm}{0.4pt} \\ XXX: CONTINUE HERE :XXX \\}
% ------------------------------------------------------------------------------------------------

{\color{red}\ol
\item Write some conclusion ideas
\item Run benchmark and add results in report (automate, generate raw Matlab/TeX output)
\item Stabilize times, statistics, use CUDA profiler(?)
\ole}

\subsection{Smith-Watermann}
% CPU: DynaProg(Scala), hand optimized C, GAPC and ADPFusion
% GPU: DynaProg(CUDA), hand optimized CUDA, CUDAlign
To maintain a fair comparison with other implementation, we use affine gap penalty variant of the Smith-Waterman algorithm. For that, we need to encode it with 3 tabulations in our grammar, whereas domain-specific application can leverage the knowledge that two of these matrices can be removed by storing appropriate information in the computation wavefront (\S\ref{calc_simplifications}).
%XXX: to compare appropriately either use 3 matrices or constant gap penalty

\begin{table}[H]\begin{center}{\small\begin{tabular}{llrrrrrrrr}\toprule
& \normalsize\bf Matrix dimension & \normalsize\bf 128 & \normalsize\bf 256 & \normalsize\bf 512 & \normalsize\bf 1024 & \normalsize\bf 2048 & \normalsize\bf 4096 & \normalsize\bf 8192 \\
\midrule \multirow{4}{*}{\rotatebox{90}{\normalsize\bf CPU $\qquad$}}
& \hdr{DynaProg}{Scala version}
	& 0.098		& 0.364		& 1.421		& 6.527		& 26.798		& 114.377	& $^{(1)}\infty$ \\
& \hdr{Optimized}{C, single thread}
	& <0.001		& <0.001		& 0.002		& 0.009		& 0.042		& 0.171		& 0.706 \\
& \hdr{GAPC}{\cite{gapc_thesis}, C, single thread}
	& 0.006		& 0.010		& 0.025		& 0.097		& 0.394		& 1.634		& 11.245 \\
& \hdr{ADP Fusion}{\cite{adp_fusion}}
	& 			& 			& 			& 			& 			& 			& 		 \\[-2pt]
\midrule \multirow{4}{*}{\rotatebox{90}{\normalsize\bf GPU $\qquad$}}
& \hdr{DynaProg}{CUDA version}
	& 0.031		& 0.037		& 0.047		& 0.068		& 0.116		& 0.202		& $^{(2)}$3.226 \\
& \hdr{Optimized}{CUDA, 64-bit}
	& 0.002		& 0.004		& 0.004		& 0.007		& 0.024		& 0.070		& 0.270 \\
& \hdr{ADP-C}{\cite{adp_gpu}}
	& 			& 			& 			& 			& 			& 			& 		\\
& \hdr{CUDAlign}{\cite{swat_linear}, version 2.0}
	& 0.011		& 0.011		& 0.011		& 0.011		& 0.011		& 0.011		& 0.012 \\
\\[-10pt] \bottomrule\end{tabular}}\end{center}
\caption{Running time of Smith-Waterman (in seconds)}\end{table}

$^{(1)}$ Extremely little progress due to intensive JVM garbage collection after some delay, even by tuning the JVM parameters ({\tt -Xss512m -Xmx8G -Xms8G -XX:MaxPermSize=8G}), independently of whether top-down or bottom-up parsing approaches are taken. After some point, most of the time is spent in the garbage collection. The aggregation function contributes to approximately 30\% of the total running time. From these result, we see that the use of complex parsing techniques are less scalable than ad-hoc methods for simple problems.

$^{(2)}$ Since the memory requirements are larger than the device capacity, the backtrack matrix overflows in the main memory, thereby significantly degrading the performance ($4\times$ slowdown). This extra memory requirement is due to the use of 3 matrices to avoid non-serial dependencies (hence requiring at least $3 \cdot 2$ bytes of memory per matrix element for backtrack).

\subsection{Zuker RNA folding}
% CPU: DynaProg(Scala), GAPC, ADPFusion and ViennaRNA
% GPU: DynaProg(CUDA), RNAFold?/Lavenier VS ViennaRNA-OpenCL?, GAPC-OpenCL?


\begin{table}[H]\begin{center}{\small\begin{tabular}{llrrrrrrrr}\toprule
& \normalsize\bf Matrix dimension & \normalsize\bf 128 & \normalsize\bf 256 & \normalsize\bf 512 & \normalsize\bf 1024 & \normalsize\bf 2048 & \normalsize\bf 4096 & \normalsize\bf 8192 \\
\midrule \multirow{4}{*}{\rotatebox{90}{\normalsize\bf CPU $\qquad$}}
& \hdr{DynaProg}{Scala version}
	& 			& 			& 			& 			& 			& 			& 		 \\
& \hdr{GAPC}{\cite{gapc_thesis}, C, single thread}
	& 			& 			& 			& 			& 			& 			& 		 \\
& \hdr{ViennaRNA}{\cite{vienna_rna}}
	& 			& 			& 			& 			& 			& 			& 		 \\[-2pt]
\midrule \multirow{4}{*}{\rotatebox{90}{\normalsize\bf GPU $\quad$}}
& \hdr{DynaProg}{CUDA version}
	& 			& 			& 			& 			& 			& 			& 		 \\
& \hdr{RNAFold}{\cite{gpu_rnafold}}
	& 			& 			& 			& 			& 			& 			& 		 \\
\\[-10pt] \bottomrule\end{tabular}}\end{center}
\caption{Running time of RNA folding (in seconds)}\end{table}

% 0.041 & 0.053 & 0.124 & 0.115 & 0.150 & 0.180 & 0.698 & 1.641 & 3.055 & 3.519 & 9.077 & 19.594 & 67.316 & 163.139


\subsection{Synthetical results}
XXX

{\color{red} We want to see the benefits of moving to CUDA, also compare to how far Scala is from C.}

RUN 5-10x until running time stabilizes on Scala

 {\color{red} Size analysis to know what storage size we require: ex: Zucker requires $O(n^2)+O(n)$ storage...}

XXX: future work: proper support of two-track grammars

XXX: future work, resize tables appropriately as in GAPL.

XXX: future work: infer automatically "always non-empty" property

\subsection{Scala parsers}

\subsection{CUDA parsers}
{\color{red} XXX: explain why slower: approx 3x more memory used per score (maintain matrix dimensions)

XXX: continue benchmarking here
}

{\color{red} XXX: Compare current implementation versus ad-hoc implementation. Compare CUDA vs Scala (we might need to ad-hoc fix stack overflows in Scala).If Zuker coefficients can be fixed, compare performance with \cite{adp_gpu} by rescaling numbers wrt to bandwidth and computation performance.}

%\end{document}
