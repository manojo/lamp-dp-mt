\input{style.sty}

\title{Draft}
\begin{document}
\maketitle
\pagestyle{headings}
\setcounter{tocdepth}{2} \tableofcontents

% ------------------------------------------------------------------------------------------------
\newpage
\section{Planning/draft}
\subsubsection*{Contributions}\ul
\item Identify DP classes and give a generalization of their shape/dependency graph
\item Provide state of the art/on par parallel implementations for all these classes
\item Generalize/simplify expression by using a DSL to implement these problems
\item Provide multi-platform support (CPU/GPU/FPGA)
\ule

\subsubsection*{Todo @TCK}
\begin{verbatim}
- backtrack on GPU for non-serial
- (timeout workaround / splitting up to 14K->12K)
- serial implementation for large memory
\end{verbatim}

\subsubsection*{Todo @Manohar}
\begin{verbatim}
- generate chain matrix recurrences to generate implementation
\end{verbatim}

Steps/timeline
\begin{verbatim}
- Theorie (?|?)
- Implementation CPU+GPU pour P/NS (3 problemes: rect, tri, parall)
- Implementation CPU+GPU pour _/S
- Lien avec le DSL
- Benchmarks
- Optimisations
\end{verbatim}

\subsection*{Plan} \ol
\item {\color{gray}
\textbf{Problems:} finish the problem description. \\ We might look towards parallel tree-raking, but it does not share much with the above algorithms (sparse version of above computations, might not scale that well). Most of the common patterns are already enclosed by the above problems. Real input size is around 300'000 (we may want to target the million, using disk). We might want to also look at an $O(n^3)$-space complexity problem (like matching 3 strings $S,T,U$).
}

All the problems we consider use 2D storage matrix, their dependencies are an union of: \ul
\item Serial dependencies
\item Non-serial horizontal or vertical dependencies (1D non-serial)
\item Non-serial horizontal+vertical dependencies in the form $M_{(i,j)} = {\rm op}_k f ( M_{(i,k)}, M_{(k,j)} ) $
\item We have not found other type of dependencies in the literature
\ule


\item \textbf{User facing language:} goals are flexibility and compactness.\ul
	\item Design the user-facing language that we want to support, which should be similar to related papers <<Algebraic Dynamic Programming>> and <<ADP fusion>>. We want to reuse their transformation to map (problem description) $\mapsto$ (kernel implementation) for a single element.
	\item We also may want to try to make implicit transformation for code like \\
		{\tt @DP def Fib(n:Int) = if (n<=2) return 1 else Fib(n-1)+Fib(n-2)}.
	\item Windowing: the user should be able to force a windowing (i.e. force a non-serial problem to be a $k$-polyadic serial problem).	
	\item Consider 3 different cases: we care about backtrack, the costs or both.
	\item Backtracking: we might want to create an operator/class that given an item produces the previous in the backtrack, or the whole sequence in correct order, or only indices.
	\ule

$\implies$ \emph{end of October}.

\item \textbf{Prototyping:} get a prototype to understand difficulties and share common base. \\ Implement a working prototype of \nameref{aswat} on CPU (for correctness), and specific platform (CUDA/FPGA). This will give us an idea of how to implement the general case. We also need to benchmark and compare both implementations to see how we compare to existing implementations and see the direction to take (which decide is faster and by how much). Here we aim to do as good an implementation for the specific platform (CPU/GPA) as possible.\\
$\implies$ \emph{end of October}.

\item \textbf{Baseline:} Also use benchmarks provided by existing implementations as baselines.\\
$\implies$ \emph{end of October}.

\item \textbf{Formalize IR:} According to experiences, describe the intermediate representation, also formalize the framework that will be provided to the code generators (i.e. memory management, ...).
\item \textbf{Full compiler stack:} enrich the compiler stack from both top-down (translate best user-facing language parsers) and bottom-up (parametric code generators), core of the work.
\item \textbf{Test and benchmark:} make sure our implementations are correct and compare them with previous papers implementations.
\ole



% --------------------------------------------------------------------------------
\input{problems}
\input{benchmarks}

% --------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{bibliography.bib}
\end{document}