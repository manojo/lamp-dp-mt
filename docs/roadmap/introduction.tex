\newpage
\section{Introduction}
% ------------------------------------------------------------------------------------------------
\subsection{Dynamic programming}
Dynamic programming consists of solving a problem by reusing subproblems solutions. A famous example of dynamic programming is the Fibonacci series that is defined by the recurrence
\[F(n+1) = F(n)+F(n-1) \qquad \text{ with } F(0)=F(1)=1 \]
which expands to (first 21 numbers)
\[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, ...\]

A typical characteristic is that an intermediate solution is reused multiple times to construct larger solutions (here $F(3)$ helps constructing $F(4)$ and $F(5)$). Reusing an existing solution avoid redoing expensive computations: with memoization (memorizing all the intermediate results we obtain) the solution of $F(n)$ would be obtained after only $n$ additions whereas without memoization it would require $F(n)-1$ additions !

Given that characteristic, there exist various categories of dynamic programming:\ul
\item Series that operates usually on a single dimension
\item Sequences alignment (matching two sequences at best), top-down grammar analysis, ...
\item Tree-related algorithms: phylogenetic, trees raking, maximum tree independent set, ...
\ule

Since the first category is inherently sequential and the third category is both hard to parallelize efficiently (similar to a sparse version of the second category) and does not share much with other classes, we focus on the second type of problems, which is also the most common.

Taking real-world examples, the average input size for sequence alignment is around 300K whereas problems like RNA folding input are usually around few thousands. Multiple input problems also require more memory: for instance matching 3 is $O(n^3)$-space complex. Since we target a single computer with one or more attached devices (GPUs, FPGAs), the available storage is relatively small if we compare it to a cluster of machines. Hence in general, we would focus on problems that are around $O(n^2)$-space and $O(n^3)$-time complexity. We encourage you to refer to the section~\ref{problems} for further classification and examples.

% ------------------------------------------------------------------------------------------------
\subsection{Scala and LMS}
\textit{<<Scala is a general purpose programming language designed to express common programming patterns in a concise, elegant, and type-safe way. It smoothly integrates features of object-oriented and functional languages, enabling programmers to be more productive. Many companies depending on Java for business critical applications are turning to Scala to boost their development productivity, applications scalability and overall reliability.>>}\footnote{\url{http://www.scala-lang.org}}

Lightweight Modular Staging (LMS) is a runtime code generation framework built on top of Scala that uses only types to distinguish between code being transformed at compilation and at runtime. Through extensive use of component technology, lightweight modular staging makes an optimizing compiler framework available at the library level, allowing programmers to tightly integrate domain-specific abstractions and optimizations into the generation process.
