\newpage
\section{Introduction}
% ------------------------------------------------------------------------------------------------
\subsection{Dynamic programming}
Dynamic programming consists of solving a problem by reusing subproblems solutions. A famous example of dynamic programming is the Fibonacci series that is defined by the recurrence
\[F(n+1) = F(n)+F(n-1) \qquad \text{ with } F(0)=F(1)=1 \]
which expands to (first 21 numbers)
\[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, ...\]

A typical characteristic is that an intermediate solution is reused multiple times to construct larger solutions (here $F(3)$ helps constructing $F(4)$ and $F(5)$). Reusing an existing solution avoid redoing expensive computations: with memoization (memorizing all the intermediate results we obtain) the solution of $F(n)$ would be obtained after only $n$ additions whereas without memoization it would require $F(n)-1$ additions !

Given that characteristic, there exist various categories of dynamic programming:\ul
\item Series that operates usually on a single dimension
\item Sequences alignment (matching two sequences at best), top-down grammar analysis, ...
\item Tree-related algorithms: phylogenetic, trees raking, maximum tree independent set, ...
\ule

Since the first category is inherently sequential and the third category is both hard to parallelize efficiently (similar to a sparse version of the second category) and does not share much with other classes, we focus on the second type of problems, which is also the most common.

Taking real-world examples, the average input size for sequence alignment is around 300K whereas problems like RNA folding input are usually around few thousands. Multiple input problems also require more memory: for instance matching 3 is $O(n^3)$-space complex. Since we target a single computer with one or more attached devices (GPUs, FPGAs), the available storage is relatively small if we compare it to a cluster of machines. Hence in general, we would focus on problems that are around $O(n^2)$-space and $O(n^3)$-time complexity. We encourage you to refer to the section~\ref{problems} for further classification and examples.

% ------------------------------------------------------------------------------------------------
\subsection{Scala and LMS}
{\color{red} XXX}
