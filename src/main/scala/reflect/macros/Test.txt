object TestMacros extends App {
  import Macros._

  case class Mat(rows:Int, cols:Int)
  def foo = tree{ (x:Mat) => x.rows * x.cols }
  println(foo.toString)

  def foo2 = tree{ (x:(Int,(Int,Int))) => x._1 * x._2._1 + x._2._2 }
  println(foo2.toString)

  type Subword = (Int,Int)
  def in(x:Int):Char = ' '
  /*
  def areBrackets = tree { (sw: Subword) => sw match { case(i,j) => j > i+1 && in(i) == '(' && in(j-1) == ')' } }
  def bracketSingle = tree { (in:(Char,(Int,Char))) => in match { case (c1,(i,c2)) => i } }
  def bracketSum = tree { (in:(Int,Int)) => in match { case (x,y) => x+y } }
  */
  def areBrackets = tree { (sw: Subword) => sw._2 > sw._1+1 && in(sw._1) == '(' && in(sw._2-1) == ')' }
  def bracketSingle = tree { (in:(Char,(Int,Char))) => in._2._1 }
  def bracketSum = tree { (in:(Int,Int)) => in._1+in._2 }

  def bracketSum2 = tree { (in:(Int,Int)) => in match { case (x,y) => x+y } }


  println(areBrackets.toString)
  println(bracketSingle.toString)
  println(bracketSum.toString)
  println(bracketSum2.toString)

}

/*
  import scala.reflect.runtime.{universe => u}
  import scala.tools.reflect.Eval

  val tr = u.reify {
    def f:(String=>String) = new (String=>String) {
      override def toString = "x+x"
      def apply(x:String):String = x+x
    }
    f
  }
  println (u showRaw tr)
  val f=tr.eval
*/
