import scala.util.parsing.combinator.syntactical.StandardTokenParsers
class CCodeGen(within:Any) extends StandardTokenParsers {
  import scala.collection.mutable.HashMap
  import lexical.NumericLit
  import lexical.StringLit
  import Macros._
  import scala.reflect.runtime.universe._

  // --------------------------------------------------------------------------
  // Types (parser)
  private var tid=0;
  private def tn(tp:String) = ts.getOrElseUpdate(tp,{ val r=tid; tid=tid+1; "tp"+r })
  private def tp_norm(s:String) = s.substring(s.lastIndexOf('.')+1).toLowerCase+"_t" // normalize type name
  val ts=new HashMap[String,String](); // struct body => name
  val c_types = Map(("Boolean","bool"),("Byte","unsigned char"),("Char","char"),("Short","short"),("Int","int"),("Long","long"),
                    ("Float","float"),("Double","double"),("String","const char*"))
  lexical.reserved ++= c_types.keys.toList
  lexical.delimiters ++= List("(", ")",".",",","*","+",";")

  def tpe:Parser[String]=( "Boolean" ^^^ "bool" | "Byte" ^^^ "unsigned char" | "String" ^^^ "const char*"
    | ("Char"|"Short"|"Int"|"Long"|"Float"|"Double") ^^ { _.toLowerCase }
    | "(" ~> repsep(tpe,",") <~ ")" ^^ { a=>tn(a.zipWithIndex.map{case(s,i)=>s+" _"+(i+1) }.mkString("; ")) }
    | repsep(ident,".") ^^ { n=>tp_norm(n.mkString(".")) }
    | failure("illegal expression type")
  )
  def parseType(str:String):String = phrase(tpe)(new lexical.Scanner(str)) match {
    case Success(ccode, _) => ccode
    case e => sys.error(e.toString)
  }

  // --------------------------------------------------------------------------
  // Case classes types
  val ctx = within.getClass.getCanonicalName
  def addClass(n:String):String = {
    val cls = Class.forName(ctx+n)
    // try mutliple attempt to find that class: absoulte class
    // within.getDeclaredClasses() ...
    // getDeclaringClass, getEnclosingClass, getSuperclass
    cls.toString match {
      case cn if (c_types.contains(cn)) => c_types(cn)
      case _ => val td = cls.getDeclaredFields.map{x=>(x.getType.toString,x.getName)}
        val tp = td.map{case (t,n)=>c_types(t.substring(0,1).toUpperCase+t.substring(1))+" "+n}.mkString("; ")
        ts.getOrElseUpdate(tp,tp_norm(n))
    }
  }

  // try to find a constructor for an existing class
  def constr(n:String):Option[String] = { // XXX: pass data types (to create on the fly the struct)
    if (!n.endsWith(".apply")) None
    else { val cl=n.substring(0,n.length-6); val tp=tp_norm(n.substring(0,n.length-6))
      if (ts.values.toSet.contains(tp)) Some(tp)
      else try { Some(addClass(cl)) } catch { case _:Throwable => None }
    }
  }

  // --------------------------------------------------------------------------
  // Functions (tree traversal)
  private var fid=0;
  private def fn(fun:(String,String,String)) = fs.getOrElseUpdate(fun,{ val r=fid; fid=fid+1; "fun"+r })
  val fs=new HashMap[(String,String,String),String](); // function (in,out,body) => name

  val base_ops= HashMap[String,String](
    ("$times","*"),("$plus","+"),("$minus","-"),("$div","/"),("$percent","%"),
    ("$greater",">"),("$greater$eq",">="),("$less","<"),("$less$eq","<="),
    ("$eq$eq","=="),("$amp$amp","&&"),("$bar$bar","||")
  );

  // XXX: need to pass back a type to cast properly the tuple into corresponding struct
  // XXX: type of expression, declaration to hoist at the function beginning
  def cc(tree:Tree):String = tree match { // XXX: return type
    // see scala/reflect/internal/Trees.scala in scala-reflect-src
    case Apply(fun@Select(qual,name),args) => base_ops.get(name.toString) match {
      case Some(op) => "("+cc(qual)+" "+op+" "+cc(args.head)+")"
      case None => val f=cc(fun);
        constr(f) match {
        // XXX: ditto if we match a custom class as well.
          case Some(cl) => "("+cl+"){"+args.map{x=>cc(x)}.mkString(",")+"}"
          // XXX: continue this
          case None if (f.startsWith("scala.Tuple")) => "(tuple??){"+args.map{x=>cc(x)}.mkString(",")+"}"
          case None => f+"("+args.map{x=>cc(x)}.mkString(",")+")"
        }
    }
    case ValDef(_,name,tp,rhs) => parseType(tp.toString)+" "+name.toString+" = "+cc(rhs)+"; "
    case Literal(Constant(x)) =>
      if (x.isInstanceOf[Char]) "'"+x.toString+"'"
      else if (x.isInstanceOf[String]) "\""+x.toString.replace("\"","\\\"")+"\""
      else x.toString
    case Select(This(_),name) => name.toString
    case Select(qual,name) => cc(qual)+"."+name
    case If(cond,thenp,elsep) => "(("+cc(cond)+")?("+cc(thenp)+"):("+cc(elsep)+"))"

    case Ident(name) => name.toString
    // Ident(newTermName("_arg"))
    //case _ => "unknown "+tree.getClass

    // XXX: issue: we don't know exactely how to bind
    case Match(selector, cases) => selector+" match { \n"+cases.map{c=>cc(c)}.mkString("\n")+"} "
    case CaseDef(pat, guard, body) => "if( is("+cc(pat)+" && "+cc(guard)+") { "+cc(body)+" } "
    case Bind(name, body) => name.toString

    case _ => showRaw(tree)
  }

  def push[T,U](f0:T=>U) = {
    if (!f0.isInstanceOf[TypedFunction]) sys.error("Push only accepts typed functions.")
    val f = f0.asInstanceOf[TypedFunction];
    val in = parseType(f.typeIn)
    val out = parseType(f.typeOut)
    val body = f.tree match {
      case Block(stats, expr) => stats.map{x=>cc(x)+"; "}.mkString("")+"_res="+cc(expr)
      case expr => "_res="+cc(expr)
    }
    fn((in,out,body))
  }

  def headers = {
    val res = ts.map{case (b,n) => "typedef struct __"+n+" "+n+";"}.mkString("\n") + "\n" +
              ts.map{case (b,n) => "struct __"+n+" { "+b+"; };"}.mkString("\n") + "\n\n" +
              fs.map{case ((i,o,b),n) => "inline "+o+" "+n+"("+i+" _arg) { "+o+" _res; "+b+"; return _res; }" }.mkString("\n") + "\n"
    ts.clear(); fs.clear(); tid=0; fid=0; res
  }
}

object TestMacros extends App {
  import Macros._
  val g=new CCodeGen(this)
  def cout = { println("-------------------------------------------------"); println(g.headers) }

  // External structures
  case class Mat(rows:Int, cols:Int)
  type Subword = (Int,Int)
  def in(x:Int):Char = '?'

  // Dummy examples
  def foo = tree{ (x:Mat) => Mat(x.cols,x.rows)  }
  def foo2 = tree{ (x:(Int,(Int,Int))) => x._1 * x._2._1 + x._2._2 }
  println("foo    : "+g.push(foo))
  println("foo2   : "+g.push(foo2))
  cout

  // Brackets (verbatim)
  /*
  def bAre = tree { (sw: Subword) => sw match { case(i,j) => j > i+1 && in(i) == '(' && in(j-1) == ')' } }
  def bSingle = tree { (in:(Char,(Int,Char))) => in match { case (c1,(i,c2)) => i } }
  def bSum = tree { (in:(Int,Int)) => in match { case (x,y) => x+y } }
  println("bAre    : "+g.push(bAre))
  println("bSingle : "+g.push(bSingle))
  println("bSum    : "+g.push(bSum))
  cout
  */

  // Brackets (modified)
  def bAre2 = tree { (sw: Subword) => sw._2 > sw._1+1 && in(sw._1) == '(' && in(sw._2-1) == ')' }
  def bSingle2 = tree { (in:(Char,(Int,Char))) => in._2._1 }
  def bSum2 = tree { (in:(Int,Int)) => in._1+in._2 }
  println("bAre2   : "+g.push(bAre2))
  println("bSingle2: "+g.push(bSingle2))
  println("bSum2   : "+g.push(bSum2))
  cout

  /*
  CLangParser.fun("(Int, Int)","Boolean","_arg._2.>(_arg._1.+(1)).&&(TestMacros.this.in(_arg._1).==('(')).&&(TestMacros.this.in(_arg._2.-(1)).==(')'))")
  CLangParser.fun("(Char, (Int, Char))","Int","_arg._2._1")
  CLangParser.fun("(Int, Int)","Int","val z:String=\"foo\"; if (true) false else true; _arg._1.+(_arg._2)")
  CLangParser.fun("(Int, Int)","(Int,Int)","if (_arg._1>_arg._2 || _arg._1<_arg._2 || _arg._1>=_arg._2 || _arg._1<=_arg._2 ) (3, 2) else (2, 3)")
  */
}

/*
  val f = foo.asInstanceOf[TypedFunction];
  println("TypeIn: "+f.typeIn)
  println("TypeOut: "+f.typeOut)
  println("Tree.tpe: "+f.tree.tpe)
  println("Tree: "+f.tree)
*/

//  c.reifyTree

/*
  import scala.reflect.runtime.{universe => u}
  import scala.tools.reflect.Eval
  val tr = u.reify {
    def f:(String=>String) = new (String=>String) {
      override def toString = "x+x"
      def apply(x:String):String = x+x
    }
    f
  }
  println (u showRaw tr)
  val f=tr.eval
*/
