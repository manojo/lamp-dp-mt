error: illegal sharing of mutable objects Sym(6)
at Sym(7)=Reflect(ArrayUpdate(Sym(3),Const(0),Sym(6)),Summary(false,false,false,false,false,List(Sym(3), Sym(6)),List(Sym(3), Sym(6)),List(Sym(3)),List(Sym(3))),List(Sym(6)))
error: write to non-mutable Sym(11) -> Some(TP(Sym(11),Reflect(ArrayApply(Sym(3),Const(0)),Summary(false,false,false,false,false,List(Sym(3)),List(Sym(3)),List(),List()),List(Sym(3), Sym(9)))))
at Sym(83)=Reflect(ArrayUpdate(Sym(11),Sym(1),Sym(82)),Summary(false,false,false,false,false,List(Sym(3)),List(Sym(3)),List(Sym(11)),List(Sym(11))),List(Sym(3), Sym(9), Sym(11)))
error: illegal sharing of mutable objects Sym(3)
at Sym(83)=Reflect(ArrayUpdate(Sym(11),Sym(1),Sym(82)),Summary(false,false,false,false,false,List(Sym(3)),List(Sym(3)),List(Sym(11)),List(Sym(11))),List(Sym(3), Sym(9), Sym(11)))
error: write to non-mutable Sym(11) -> Some(TP(Sym(11),Reflect(ArrayApply(Sym(3),Const(0)),Summary(false,false,false,false,false,List(Sym(3)),List(Sym(3)),List(),List()),List(Sym(3), Sym(9)))))
at Sym(87)=Reflect(IfThenElse(Sym(10),Block(Sym(86)),Block(Sym(16))),Summary(false,false,false,false,false,List(Sym(3)),List(),List(Sym(11)),List()),List(Sym(3), Sym(9)))
/*****************************************
  Emitting Generated Code                  
*******************************************/
class test-matmult extends ((Array[scala.Tuple2[Int, Int]])=>(scala.Tuple3[Int, Int, Int])) {
def apply(x0:Array[scala.Tuple2[Int, Int]]): scala.Tuple3[Int, Int, Int] = {
val x1 = x0.length
val x2 = x1 + 1
val x3 = new Array[Array[scala.Tuple3[Int, Int, Int]]](x2)
var x5 : Int = 0
val x9 = while (x5 < x2) {
val x6 = new Array[scala.Tuple3[Int, Int, Int]](x2)
val x7 = x3(0) = x6
x7
x5 = x5 + 1
}
val x10 = 0 <= x1
val x87 = if (x10) {
val x11 = x3(0)
val x23 = 0 < x1
val x12 = 0 + 1
val x57 = if (x23) {
val x24 = 0 == 0
val x27 = if (x24) {
x12
} else {
val x25 = x1 - 0
val x26 = java.lang.Math.max(x12, x25)
x26
}
val x31 = if (x24) {
val x28 = x1 - 1
x28
} else {
val x28 = x1 - 1
val x29 = 0 + 0
val x30 = java.lang.Math.min(x28, x29)
x30
}
val x32 = x31 + 1
val x33 = x27 until x32
val x34 = x33.toList
val x16 = List()
val x55 = x34.flatMap { x35 => 
val x36 = 0 <= x35
val x41 = if (x36) {
val x37 = x3(0)
val x38 = x37(x35)
val x39 = List(x38)
x39
} else {
x16
}
val x43 = x35 <= x1
val x53 = x41.flatMap { x42 => 
val x48 = if (x43) {
val x44 = x3(x35)
val x45 = x44(x1)
val x46 = List(x45)
x46
} else {
x16
}
val x51 = x48.map{
x49 => 
val x50 = (x42,x49)
x50
}
x51
}
x53
}
x55
} else {
val x16 = List()
x16
}
val x13 = x12 == x1
val x17 = if (x13) {
val x14 = x0(0)
val x15 = List(x14)
x15
} else {
val x16 = List()
x16
}
val x22 = x17.map{
x18 => 
val x19 = x18._1
val x20 = x18._2
val x21 = (x19,0,x20)
x21
}
val x72 = x57.map{
x58 => 
val x59 = x58._1
val x61 = x59._1
val x60 = x58._2
val x66 = x60._3
val x62 = x59._2
val x65 = x60._2
val x67 = x62 + x65
val x63 = x59._3
val x68 = x61 * x63
val x69 = x68 * x66
val x70 = x67 + x69
val x71 = (x61,x70,x66)
x71
}
val x73 = x22 ::: x72
val x74 = x73.isEmpty
val x81 = if (x74) {
x73
} else {
val x79 = x73.minBy{
x75 => 
val x77 = x75._2
x77
}
val x80 = List(x79)
x80
}
val x82 = x81.head
val x83 = x11(x1) = x82
val x84 = x11(x1)
val x85 = List(x84)
x85
} else {
val x16 = List()
x16
}
val x88 = x87.head
x88
}
}
/*****************************************
  End of Generated Code                  
*******************************************/
