
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     gapc-2012.07.23
// 
//   GAP-C call:
//     gapc -t -i mfe adpfold.gap 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "out.hh"

#include <rtlib/subopt.hh>
#include "rna.hh"
#include "adpf_filter.hh"

#include <rtlib/generic_opts.hh>

int &  out::nt_closed(unsigned int t_0_i, unsigned int t_0_j)
{
  if (closed_table.is_tabulated(t_0_i, t_0_j))
    {
      return closed_table.get(t_0_i, t_0_j);
    }

  int answers;
  empty(answers);
  empty( answers);


  if (stackpairing(t_0_seq, t_0_i, t_0_j))
  {
    int ret_1 = nt_stack(t_0_i, t_0_j);
    if (is_not_empty(ret_1))
      {
        push_back_min( answers, ret_1);
      }

    int ret_2 = nt_hairpin(t_0_i, t_0_j);
    if (is_not_empty(ret_2))
      {
        push_back_min( answers, ret_2);
      }

    int ret_3 = nt_leftB(t_0_i, t_0_j);
    if (is_not_empty(ret_3))
      {
        push_back_min( answers, ret_3);
      }

    int ret_4 = nt_rightB(t_0_i, t_0_j);
    if (is_not_empty(ret_4))
      {
        push_back_min( answers, ret_4);
      }

    int ret_5 = nt_iloop(t_0_i, t_0_j);
    if (is_not_empty(ret_5))
      {
        push_back_min( answers, ret_5);
      }

    int ret_6 = nt_multiloop(t_0_i, t_0_j);
    if (is_not_empty(ret_6))
      {
        push_back_min( answers, ret_6);
      }

  }

  int eval = h(answers);
  erase( answers);
  closed_table.set( t_0_i, t_0_j, eval);
  return closed_table.get(t_0_i, t_0_j);
}

int &  out::nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return dangle_table.get(t_0_i, t_0_j);
    }

  int answers;
  empty( answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 7))
  {
    TUSubsequence ret_3 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        int ret_2 = nt_closed(t_0_i, t_0_j);
        int a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            ret_0 = dlr(a_0, a_1, a_2);
          }

        else
          {
            empty( ret_0);
          }

        erase( a_1);
      }

      else
        {
          empty( ret_0);
        }

      erase( a_0);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_2);
  }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  dangle_table.set( t_0_i, t_0_j, answers);
  return dangle_table.get(t_0_i, t_0_j);
}

int out::nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return int_zero;
    }

  int answers;
  empty( answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 7))
  {
    TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_4 = ret_6;
    if (is_not_empty(a_4))
    {
      TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
      TUSubsequence a_3 = ret_5;
      if (is_not_empty(a_3))
      {
        TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
        TUSubsequence a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            TUSubsequence ret_3;
            empty( ret_3);
            TUSubsequence ret_4;
            if (minsize(t_0_seq, (t_0_i + 2), (t_0_j - 2), 3))
              {
                ret_4 = REGION(t_0_seq, (t_0_i + 2), (t_0_j - 2));
              }

            else
              {
                empty( ret_4);
              }

            ret_3 = ret_4;
            TUSubsequence a_2 = ret_3;
            if (is_not_empty(a_2))
              {
                ret_0 = hl(a_0, a_1, a_2, a_3, a_4);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_2);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_0);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_1);
      }

      else
        {
          empty( ret_0);
        }

      erase( a_3);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

int out::nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 13))
    {
      return int_zero;
    }

  int answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 13))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 3); ((t_0_k_0 <= (t_0_j - 10)) && (t_0_k_0 <= (t_0_i + 32))); ++t_0_k_0)
      {
        for(        unsigned int t_0_k_1 = (((t_0_j - (t_0_k_0 + 7)) >= 32)) ? ((t_0_j - 32)) : ((t_0_k_0 + 7)); (t_0_k_1 <= (t_0_j - 3)); ++t_0_k_1)
        {
          TUSubsequence ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
          TUSubsequence a_6 = ret_7;
          if (is_not_empty(a_6))
          {
            TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            TUSubsequence a_5 = ret_6;
            if (is_not_empty(a_5))
            {
              TUSubsequence ret_5;
              if (maxsize(t_0_seq, t_0_k_1, (t_0_j - 2), 30))
                {
                  ret_5 = REGION(t_0_seq, t_0_k_1, (t_0_j - 2));
                }

              else
                {
                  empty( ret_5);
                }

              TUSubsequence a_4 = ret_5;
              if (is_not_empty(a_4))
              {
                TUSubsequence ret_3;
                if (maxsize(t_0_seq, (t_0_i + 2), t_0_k_0, 30))
                  {
                    ret_3 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
                  }

                else
                  {
                    empty( ret_3);
                  }

                TUSubsequence a_2 = ret_3;
                if (is_not_empty(a_2))
                {
                  TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
                  TUSubsequence a_1 = ret_2;
                  if (is_not_empty(a_1))
                  {
                    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                    TUSubsequence a_0 = ret_1;
                    if (is_not_empty(a_0))
                    {
                      int ret_4 = nt_closed(t_0_k_0, t_0_k_1);
                      int a_3 = ret_4;
                      if (is_not_empty(a_3))
                      {
                        int ans = il(a_0, a_1, a_2, a_3, a_4, a_5, a_6);
                        push_back_min( answers, ans);
                      }

                      erase( a_3);
                    }

                    erase( a_0);
                  }

                  erase( a_1);
                }

                erase( a_2);
              }

              erase( a_4);
            }

            erase( a_5);
          }

          erase( a_6);
        }

      }

    }

  int eval = h(answers);
  erase( answers);
  return eval;
}

int out::nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return int_zero;
    }

  int answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 3); ((t_0_k_0 <= (t_0_j - 9)) && (t_0_k_0 <= (t_0_i + 32))); ++t_0_k_0)
      {
        TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_5 = ret_6;
        if (is_not_empty(a_5))
        {
          TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_4 = ret_5;
          if (is_not_empty(a_4))
          {
            TUSubsequence ret_3;
            if (maxsize(t_0_seq, (t_0_i + 2), t_0_k_0, 30))
              {
                ret_3 = REGION(t_0_seq, (t_0_i + 2), t_0_k_0);
              }

            else
              {
                empty( ret_3);
              }

            TUSubsequence a_2 = ret_3;
            if (is_not_empty(a_2))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  int ret_4 = nt_closed(t_0_k_0, (t_0_j - 2));
                  int a_3 = ret_4;
                  if (is_not_empty(a_3))
                  {
                    int ans = bl(a_0, a_1, a_2, a_3, a_4, a_5);
                    push_back_min( answers, ans);
                  }

                  erase( a_3);
                }

                erase( a_0);
              }

              erase( a_1);
            }

            erase( a_2);
          }

          erase( a_4);
        }

        erase( a_5);
      }

    }

  int eval = h(answers);
  erase( answers);
  return eval;
}

int &  out::nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps_table.get(t_0_i, t_0_j);
    }

  int answers;
  empty(answers);
  empty( answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 15))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      int ret_2 = nt_ml_comps((t_0_i + 1), t_0_j);
      int a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          ret_0 = sadd(a_0, a_1);
        }

      else
        {
          empty( ret_0);
        }

      erase( a_1);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_min( answers, ret_0);
    }


  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        int ret_7 = nt_ml_comps1(t_0_k_0, t_0_j);
        int a_4 = ret_7;
        if (is_not_empty(a_4))
        {
          int ret_4;
          empty( ret_4);
          int ret_5;
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            int ret_6 = nt_dangle(t_0_i, t_0_k_0);
            int a_3 = ret_6;
            if (is_not_empty(a_3))
              {
                ret_5 = ul(a_3);
              }

            else
              {
                empty( ret_5);
              }

            erase( a_3);
          }

          else
            {
              empty( ret_5);
            }

          ret_4 = ret_5;
          int a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            int ans = app(a_2, a_4);
            push_back_min( answers, ans);
          }

          erase( a_2);
        }

        erase( a_4);
      }

    }

  int eval = h(answers);
  erase( answers);
  ml_comps_table.set( t_0_i, t_0_j, eval);
  return ml_comps_table.get(t_0_i, t_0_j);
}

int &  out::nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps1_table.get(t_0_i, t_0_j);
    }

  int answers;
  empty(answers);
  empty( answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 8))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      int ret_2 = nt_ml_comps1((t_0_i + 1), t_0_j);
      int a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          ret_0 = sadd(a_0, a_1);
        }

      else
        {
          empty( ret_0);
        }

      erase( a_1);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_min( answers, ret_0);
    }


  if (((t_0_j - t_0_i) >= 14))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= (t_0_j - 7)); ++t_0_k_0)
      {
        int ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        int a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          int ret_4;
          if (((t_0_k_0 - t_0_i) >= 7))
          {
            int ret_5 = nt_dangle(t_0_i, t_0_k_0);
            int a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                ret_4 = ul(a_3);
              }

            else
              {
                empty( ret_4);
              }

            erase( a_3);
          }

          else
            {
              empty( ret_4);
            }

          int a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            int ans = app(a_2, a_4);
            push_back_min( answers, ans);
          }

          erase( a_2);
        }

        erase( a_4);
      }

    }

  int ret_7;
  if (((t_0_j - t_0_i) >= 7))
  {
    int ret_8 = nt_dangle(t_0_i, t_0_j);
    int a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        ret_7 = ul(a_5);
      }

    else
      {
        empty( ret_7);
      }

    erase( a_5);
  }

  else
    {
      empty( ret_7);
    }

  if (is_not_empty(ret_7))
    {
      push_back_min( answers, ret_7);
    }


  if (((t_0_j - t_0_i) >= 8))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 7); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          int ret_10;
          if (((t_0_k_1 - t_0_i) >= 7))
          {
            int ret_11 = nt_dangle(t_0_i, t_0_k_1);
            int a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                ret_10 = ul(a_7);
              }

            else
              {
                empty( ret_10);
              }

            erase( a_7);
          }

          else
            {
              empty( ret_10);
            }

          int a_6 = ret_10;
          if (is_not_empty(a_6))
          {
            int ans = addss(a_6, a_8);
            push_back_min( answers, ans);
          }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  int eval = h(answers);
  erase( answers);
  ml_comps1_table.set( t_0_i, t_0_j, eval);
  return ml_comps1_table.get(t_0_i, t_0_j);
}

int out::nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 18))
    {
      return int_zero;
    }

  int answers;
  empty( answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 18))
  {
    TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_4 = ret_5;
    if (is_not_empty(a_4))
    {
      TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
      TUSubsequence a_3 = ret_4;
      if (is_not_empty(a_3))
      {
        TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
        TUSubsequence a_1 = ret_2;
        if (is_not_empty(a_1))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            int ret_3 = nt_ml_comps((t_0_i + 2), (t_0_j - 2));
            int a_2 = ret_3;
            if (is_not_empty(a_2))
              {
                ret_0 = ml(a_0, a_1, a_2, a_3, a_4);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_2);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_0);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_1);
      }

      else
        {
          empty( ret_0);
        }

      erase( a_3);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

int out::nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return int_zero;
    }

  int answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      for(      unsigned int t_0_k_0 = (((t_0_j - (t_0_i + 9)) >= 32)) ? ((t_0_j - 32)) : ((t_0_i + 9)); (t_0_k_0 <= (t_0_j - 3)); ++t_0_k_0)
      {
        TUSubsequence ret_6 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_5 = ret_6;
        if (is_not_empty(a_5))
        {
          TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
          TUSubsequence a_4 = ret_5;
          if (is_not_empty(a_4))
          {
            TUSubsequence ret_4;
            if (maxsize(t_0_seq, t_0_k_0, (t_0_j - 2), 30))
              {
                ret_4 = REGION(t_0_seq, t_0_k_0, (t_0_j - 2));
              }

            else
              {
                empty( ret_4);
              }

            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_2 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  int ret_3 = nt_closed((t_0_i + 2), t_0_k_0);
                  int a_2 = ret_3;
                  if (is_not_empty(a_2))
                  {
                    int ans = br(a_0, a_1, a_2, a_3, a_4, a_5);
                    push_back_min( answers, ans);
                  }

                  erase( a_2);
                }

                erase( a_0);
              }

              erase( a_1);
            }

            erase( a_3);
          }

          erase( a_4);
        }

        erase( a_5);
      }

    }

  int eval = h(answers);
  erase( answers);
  return eval;
}

int out::nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return int_zero;
    }

  int answers;
  empty( answers);
  int ret_0;
  if (((t_0_j - t_0_i) >= 9))
  {
    TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        int ret_2 = nt_closed((t_0_i + 1), (t_0_j - 1));
        int a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            ret_0 = sr(a_0, a_1, a_2);
          }

        else
          {
            empty( ret_0);
          }

        erase( a_1);
      }

      else
        {
          empty( ret_0);
        }

      erase( a_0);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_2);
  }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

int &  out::nt_struct(unsigned int t_0_i)
{
  if (struct_table.is_tabulated(t_0_i))
    {
      return struct_table.get(t_0_i);
    }

  int answers;
  empty(answers);
  empty( answers);
  int ret_0;
  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      int ret_2 = nt_struct((t_0_i + 1));
      int a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          ret_0 = sadd(a_0, a_1);
        }

      else
        {
          empty( ret_0);
        }

      erase( a_1);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_min( answers, ret_0);
    }


  if (((t_0_right_most - t_0_i) >= 7))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 7); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        int ret_5 = nt_struct(t_0_k_0);
        int a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          int ret_4 = nt_dangle(t_0_i, t_0_k_0);
          int a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            int ans = cadd(a_2, a_3);
            push_back_min( answers, ans);
          }

          erase( a_2);
        }

        erase( a_3);
      }

    }

  int ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    bool ret_7 = EMPTY(t_0_seq, t_0_i, t_0_i);
    bool a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back_min( answers, ret_6);
    }

  int eval = h(answers);
  erase( answers);
  struct_table.set( t_0_i, eval);
  return struct_table.get(t_0_i);
}


int out::addss(int c1, const TUSubsequence & e)
{
#line 368 "adpfold.gap"
  return (c1 + ss_energy(e));
#line 1036 "out.cc"
}

int out::app(int c1, int c)
{
#line 360 "adpfold.gap"
  return (c1 + c);
#line 1043 "out.cc"
}

int out::bl(const TUSubsequence & bl, const TUSubsequence & f1, const TUSubsequence & x, int e, const TUSubsequence & f2, const TUSubsequence & br)
{
#line 341 "adpfold.gap"
  return ((e + bl_energy(x, f2)) + sr_energy(bl, br));
#line 1050 "out.cc"
}

int out::br(const TUSubsequence & bl, const TUSubsequence & f1, int e, const TUSubsequence & x, const TUSubsequence & f2, const TUSubsequence & br)
{
#line 346 "adpfold.gap"
  return ((e + br_energy(f1, x)) + sr_energy(bl, br));
#line 1057 "out.cc"
}

int out::cadd(int x, int e)
{
#line 322 "adpfold.gap"
  return (x + e);
#line 1064 "out.cc"
}

int out::dlr(const TUSubsequence & lb, int e, const TUSubsequence & rb)
{
#line 326 "adpfold.gap"
  return ((e + ext_mismatch_energy(lb, rb)) + termau_energy(lb, rb));
#line 1071 "out.cc"
}

int out::h(int i)
{
  return i;
  return minimum(i);
}

int out::hl(const TUSubsequence & lb, const TUSubsequence & f1, const TUSubsequence & x, const TUSubsequence & f2, const TUSubsequence & rb)
{
#line 336 "adpfold.gap"
  return (hl_energy(x) + sr_energy(lb, rb));
#line 1084 "out.cc"
}

int out::il(const TUSubsequence & f1, const TUSubsequence & f2, const TUSubsequence & r1, int x, const TUSubsequence & r2, const TUSubsequence & f3, const TUSubsequence & f4)
{
#line 351 "adpfold.gap"
  return ((x + il_energy(r1, r2)) + sr_energy(f1, f4));
#line 1091 "out.cc"
}

int out::ml(const TUSubsequence & bl, const TUSubsequence & f1, int x, const TUSubsequence & f2, const TUSubsequence & br)
{
#line 355 "adpfold.gap"
  return (((((ml_energy() + ul_energy()) + x) + termau_energy(f1, f2)) + sr_energy(bl, br)) + ml_mismatch_energy(f1, f2));
#line 1098 "out.cc"
}

int out::nil(bool VOID_INTERNAL3)
{
#line 376 "adpfold.gap"
  return 0;
#line 1105 "out.cc"
}

int out::sadd(const TUSubsequence & lb, int e)
{
#line 318 "adpfold.gap"
  return e;
#line 1112 "out.cc"
}

int out::sr(const TUSubsequence & lb, int e, const TUSubsequence & rb)
{
#line 331 "adpfold.gap"
  return (e + sr_energy(lb, rb));
#line 1119 "out.cc"
}

int out::ul(int c1)
{
#line 364 "adpfold.gap"
  return (ul_energy() + c1);
#line 1126 "out.cc"
}


    void out::cyk()
{

}



#ident "$Id: Compiled with gapc gapc-2012.07.23 $"

