
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     gapc-2012.07.23
// 
//   GAP-C call:
//     gapc -t matmult.gap 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "out.hh"

#include <rtlib/subopt.hh>

#include <rtlib/generic_opts.hh>

tuple &  out::nt_matrix(unsigned int t_0_i, unsigned int t_0_j)
{
  if (matrix_table.is_tabulated(t_0_i, t_0_j))
    {
      return matrix_table.get(t_0_i, t_0_j);
    }

  tuple answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 3))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 1); (t_0_k_0 <= (t_0_j - 2)); ++t_0_k_0)
      {
        int ret_3 = INT(t_0_seq, (t_0_k_0 + 1), t_0_j);
        int a_3 = ret_3;
        if (is_not_empty(a_3))
        {
          char ret_2;
          if (((((t_0_k_0 + 1) - t_0_k_0) >= 1) && (((t_0_k_0 + 1) - t_0_k_0) <= 1)))
            {
              ret_2 = CHAR(t_0_seq, t_0_k_0, (t_0_k_0 + 1), ',');
            }

          else
            {
              empty( ret_2);
            }

          char a_1 = ret_2;
          if (is_not_empty(a_1))
          {
            int ret_1 = INT(t_0_seq, t_0_i, t_0_k_0);
            int a_0 = ret_1;
            if (is_not_empty(a_0))
            {
              tuple ans = single(a_0, a_1, a_3);
              push_back_min( answers, ans);
            }

            erase( a_0);
          }

          erase( a_1);
        }

        erase( a_3);
      }

    }


  if (((t_0_j - t_0_i) >= 7))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 3); (t_0_k_1 <= (t_0_j - 4)); ++t_0_k_1)
      {
        char ret_6;
        if (((((t_0_k_1 + 1) - t_0_k_1) >= 1) && (((t_0_k_1 + 1) - t_0_k_1) <= 1)))
          {
            ret_6 = CHAR(t_0_seq, t_0_k_1, (t_0_k_1 + 1), ',');
          }

        else
          {
            empty( ret_6);
          }

        char a_5 = ret_6;
        if (is_not_empty(a_5))
        {
          tuple ret_7 = nt_matrix((t_0_k_1 + 1), t_0_j);
          tuple a_7 = ret_7;
          if (is_not_empty(a_7))
          {
            tuple ret_5 = nt_matrix(t_0_i, t_0_k_1);
            tuple a_4 = ret_5;
            if (is_not_empty(a_4))
            {
              tuple ans = mult(a_4, a_5, a_7);
              push_back_min( answers, ans);
            }

            erase( a_4);
          }

          erase( a_7);
        }

        erase( a_5);
      }

    }

  tuple eval = h(answers);
  erase( answers);
  matrix_table.set( t_0_i, t_0_j, eval);
  return matrix_table.get(t_0_i, t_0_j);
}


tuple out::h(tuple l)
{
  return l;
  return minimum(l);
}

tuple out::mult(tuple a, char o, tuple b)
{
#line 21 "matmult.gap"
  tuple x;
  x.ops = ((a.ops + b.ops) + ((a.rows * a.cols) * b.cols));
  x.rows = a.rows;
  x.cols = b.cols;
  return x;
#line 136 "out.cc"
}

tuple out::single(int r, char a, int c)
{
#line 13 "matmult.gap"
  tuple x;
  x.ops = 0;
  x.rows = r;
  x.cols = c;
  return x;
#line 147 "out.cc"
}


    void out::cyk()
{

}



#ident "$Id: Compiled with gapc gapc-2012.07.23 $"

