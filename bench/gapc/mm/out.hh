
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     gapc-2012.07.23
// 
//   GAP-C call:
//     gapc -t matmult.gap 
// 
// 


#ifndef out_hh
#define out_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<char, unsigned> TUSubsequence;

struct tuple {
  int ops;
  int rows;
  int cols;
  bool empty_;
  tuple() : empty_(false) {}
bool operator>(const tuple& other) const { return ops > other.ops; }
bool operator<(const tuple& other) const { return ops < other.ops; }
bool operator==(const tuple& other) const { return ops == other.ops; }
template <typename T> bool operator>(const T &other) const {return ops > other; }
template <typename T> bool operator<(const T &other) const {return ops < other; }
template <typename T> bool operator==(const T &other) const {return ops == other; }


tuple(int i) : ops(i), empty_(false) {}
tuple operator+(const tuple &other) const
{
assert(!empty_); assert(!other.empty_);
return tuple(ops + other.ops);
}
tuple operator-(const tuple &other) const
{
assert(!empty_);
if (other.empty_) return tuple(ops);
return tuple(ops - other.ops);
}
bool operator<=(const tuple& other) const {
assert(!empty_); assert(!other.empty_);
return ops <= other.ops;
}

};

inline std::ostream &operator<<(std::ostream &o, const tuple &tuple) {
  o << '('   << tuple.ops   << ", " << tuple.rows
   << ", " << tuple.cols
   << ')' ;
  return o;
}

inline void empty(tuple &e) {e.empty_ = true; }
inline bool is_empty(const tuple &e) { return e.empty_; }
#include <rtlib/subopt.hh>

#include <rtlib/generic_opts.hh>

class out {

  public:
Basic_Sequence<char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

tuple Bint_opsG_int_rowsG_int_colsG_E_zero;

class matrix_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<tuple > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
tuple zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

matrix_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 3))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
tuple &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 3))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, tuple e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 3))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
matrix_table_t matrix_table;



void init(const gapc::Opts &opts)
{
const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
  matrix_table.init( t_0_seq.size(), "matrix_table");
empty(Bint_opsG_int_rowsG_int_colsG_E_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
}

  private:
    tuple &  nt_matrix(unsigned int t_0_i, unsigned int t_0_j);

    tuple h(tuple l);
    tuple mult(tuple a, char o, tuple b);
    tuple single(int r, char a, int c);


 public:
   void cyk();

 public:
   tuple &  run()
{
  return nt_matrix(t_0_left_most, t_0_right_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      matrix_table.print_stats(o, "matrix_table");
#endif
}

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
if (is_empty(res))
  out << "[]\n";
else
  out << res << '\n';

}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef out class_name;
  typedef tuple &  return_type;
}
#endif

#endif

