/*
* generated by Xtext
*/
package fr.irisa.cairn.model.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import fr.irisa.cairn.model.services.MathematicaGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class MathematicaParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private MathematicaGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_Alternatives(this, this, 0, inst);
			case 1: return new ASTNode_Group(this, this, 1, inst);
			case 2: return new BuiltInNode_Group(this, this, 2, inst);
			case 3: return new ASTLeaf_Alternatives(this, this, 3, inst);
			case 4: return new IntLeaf_Group(this, this, 4, inst);
			case 5: return new StringLeaf_ValueAssignment(this, this, 5, inst);
			case 6: return new SymbolLeaf_NameAssignment(this, this, 6, inst);
			case 7: return new FloatLeaf_Group(this, this, 7, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Node ****************
 *
 * Node:
 * 	ASTNode | ASTLeaf | BuiltInNode;
 *
 **/

// ASTNode | ASTLeaf | BuiltInNode
protected class Node_Alternatives extends AlternativesToken {

	public Node_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNodeAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_ASTNodeParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Node_ASTLeafParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Node_BuiltInNodeParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getASTNodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBuiltInNodeRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getFloatLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSymbolLeafRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ASTNode
protected class Node_ASTNodeParserRuleCall_0 extends RuleCallToken {
	
	public Node_ASTNodeParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNodeAccess().getASTNodeParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getASTNodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ASTNode_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ASTLeaf
protected class Node_ASTLeafParserRuleCall_1 extends RuleCallToken {
	
	public Node_ASTLeafParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNodeAccess().getASTLeafParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTLeaf_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSymbolLeafRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ASTLeaf_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// BuiltInNode
protected class Node_BuiltInNodeParserRuleCall_2 extends RuleCallToken {
	
	public Node_BuiltInNodeParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNodeAccess().getBuiltInNodeParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBuiltInNodeRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BuiltInNode_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Node ****************/


/************ begin Rule ASTNode ****************
 *
 * ASTNode:
 * 	name=ID "[" (children+=Node ("," children+=Node)*)? "]";
 *
 **/

// name=ID "[" (children+=Node ("," children+=Node)*)? "]"
protected class ASTNode_Group extends GroupToken {
	
	public ASTNode_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_RightSquareBracketKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getASTNodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// name=ID
protected class ASTNode_NameAssignment_0 extends AssignmentToken  {
	
	public ASTNode_NameAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getASTNodeAccess().getNameIDTerminalRuleCall_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getASTNodeAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "["
protected class ASTNode_LeftSquareBracketKeyword_1 extends KeywordToken  {
	
	public ASTNode_LeftSquareBracketKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getLeftSquareBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_NameAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// (children+=Node ("," children+=Node)*)?
protected class ASTNode_Group_2 extends GroupToken {
	
	public ASTNode_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_Group_2_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ASTNode_ChildrenAssignment_2_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// children+=Node
protected class ASTNode_ChildrenAssignment_2_0 extends AssignmentToken  {
	
	public ASTNode_ChildrenAssignment_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getChildrenAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("children",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("children");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getASTNodeAccess().getChildrenNodeParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ASTNode_LeftSquareBracketKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," children+=Node)*
protected class ASTNode_Group_2_1 extends GroupToken {
	
	public ASTNode_Group_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_ChildrenAssignment_2_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class ASTNode_CommaKeyword_2_1_0 extends KeywordToken  {
	
	public ASTNode_CommaKeyword_2_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getCommaKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_Group_2_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ASTNode_ChildrenAssignment_2_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// children+=Node
protected class ASTNode_ChildrenAssignment_2_1_1 extends AssignmentToken  {
	
	public ASTNode_ChildrenAssignment_2_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getChildrenAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("children",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("children");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getASTNodeAccess().getChildrenNodeParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ASTNode_CommaKeyword_2_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "]"
protected class ASTNode_RightSquareBracketKeyword_3 extends KeywordToken  {
	
	public ASTNode_RightSquareBracketKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getASTNodeAccess().getRightSquareBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTNode_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ASTNode_LeftSquareBracketKeyword_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule ASTNode ****************/


/************ begin Rule BuiltInNode ****************
 *
 * BuiltInNode:
 * 	keyword=KeyWord "[" (children+=Node ("," children+=Node)*)? "]";
 *
 **/

// keyword=KeyWord "[" (children+=Node ("," children+=Node)*)? "]"
protected class BuiltInNode_Group extends GroupToken {
	
	public BuiltInNode_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_RightSquareBracketKeyword_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBuiltInNodeRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// keyword=KeyWord
protected class BuiltInNode_KeywordAssignment_0 extends AssignmentToken  {
	
	public BuiltInNode_KeywordAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getKeywordAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("keyword",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("keyword");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getBuiltInNodeAccess().getKeywordKeyWordTerminalRuleCall_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getBuiltInNodeAccess().getKeywordKeyWordTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "["
protected class BuiltInNode_LeftSquareBracketKeyword_1 extends KeywordToken  {
	
	public BuiltInNode_LeftSquareBracketKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getLeftSquareBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_KeywordAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// (children+=Node ("," children+=Node)*)?
protected class BuiltInNode_Group_2 extends GroupToken {
	
	public BuiltInNode_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_Group_2_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BuiltInNode_ChildrenAssignment_2_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// children+=Node
protected class BuiltInNode_ChildrenAssignment_2_0 extends AssignmentToken  {
	
	public BuiltInNode_ChildrenAssignment_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getChildrenAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("children",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("children");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getBuiltInNodeAccess().getChildrenNodeParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuiltInNode_LeftSquareBracketKeyword_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," children+=Node)*
protected class BuiltInNode_Group_2_1 extends GroupToken {
	
	public BuiltInNode_Group_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_ChildrenAssignment_2_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class BuiltInNode_CommaKeyword_2_1_0 extends KeywordToken  {
	
	public BuiltInNode_CommaKeyword_2_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getCommaKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_Group_2_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BuiltInNode_ChildrenAssignment_2_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// children+=Node
protected class BuiltInNode_ChildrenAssignment_2_1_1 extends AssignmentToken  {
	
	public BuiltInNode_ChildrenAssignment_2_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getChildrenAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Node_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("children",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("children");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNodeRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getBuiltInNodeAccess().getChildrenNodeParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BuiltInNode_CommaKeyword_2_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "]"
protected class BuiltInNode_RightSquareBracketKeyword_3 extends KeywordToken  {
	
	public BuiltInNode_RightSquareBracketKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBuiltInNodeAccess().getRightSquareBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BuiltInNode_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new BuiltInNode_LeftSquareBracketKeyword_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule BuiltInNode ****************/


/************ begin Rule ASTLeaf ****************
 *
 * ASTLeaf:
 * 	IntLeaf | StringLeaf | FloatLeaf | SymbolLeaf;
 *
 **/

// IntLeaf | StringLeaf | FloatLeaf | SymbolLeaf
protected class ASTLeaf_Alternatives extends AlternativesToken {

	public ASTLeaf_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getASTLeafAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ASTLeaf_IntLeafParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ASTLeaf_StringLeafParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new ASTLeaf_FloatLeafParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new ASTLeaf_SymbolLeafParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIntLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLeafRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSymbolLeafRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// IntLeaf
protected class ASTLeaf_IntLeafParserRuleCall_0 extends RuleCallToken {
	
	public ASTLeaf_IntLeafParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getASTLeafAccess().getIntLeafParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IntLeaf_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntLeafRule().getType().getClassifier())
			return null;
		if(checkForRecursion(IntLeaf_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// StringLeaf
protected class ASTLeaf_StringLeafParserRuleCall_1 extends RuleCallToken {
	
	public ASTLeaf_StringLeafParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getASTLeafAccess().getStringLeafParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringLeaf_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringLeafRule().getType().getClassifier())
			return null;
		if(checkForRecursion(StringLeaf_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// FloatLeaf
protected class ASTLeaf_FloatLeafParserRuleCall_2 extends RuleCallToken {
	
	public ASTLeaf_FloatLeafParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getASTLeafAccess().getFloatLeafParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatLeafRule().getType().getClassifier())
			return null;
		if(checkForRecursion(FloatLeaf_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// SymbolLeaf
protected class ASTLeaf_SymbolLeafParserRuleCall_3 extends RuleCallToken {
	
	public ASTLeaf_SymbolLeafParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getASTLeafAccess().getSymbolLeafParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new SymbolLeaf_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSymbolLeafRule().getType().getClassifier())
			return null;
		if(checkForRecursion(SymbolLeaf_NameAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ASTLeaf ****************/


/************ begin Rule IntLeaf ****************
 *
 * //BuiltInNode : ListNode | SetNode;
 * //
 * //ListNode : 
 * //	"List"  '[' (children+=Node (',' children+=Node)*)? ']';
 * //
 * //SetNode : 
 * //	"List"  '[' (children+=Node (',' children+=Node)*)? ']';
 * IntLeaf:
 * 	signed="-"? value=INT;
 *
 **/

// signed="-"? value=INT
protected class IntLeaf_Group extends GroupToken {
	
	public IntLeaf_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIntLeafAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IntLeaf_ValueAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIntLeafRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// signed="-"?
protected class IntLeaf_SignedAssignment_0 extends AssignmentToken  {
	
	public IntLeaf_SignedAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntLeafAccess().getSignedAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("signed",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("signed");
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getIntLeafAccess().getSignedHyphenMinusKeyword_0_0(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getIntLeafAccess().getSignedHyphenMinusKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// value=INT
protected class IntLeaf_ValueAssignment_1 extends AssignmentToken  {
	
	public IntLeaf_ValueAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntLeafAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IntLeaf_SignedAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 1, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getIntLeafAccess().getValueINTTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getIntLeafAccess().getValueINTTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule IntLeaf ****************/


/************ begin Rule StringLeaf ****************
 *
 * StringLeaf:
 * 	value=STRING;
 *
 **/

// value=STRING
protected class StringLeaf_ValueAssignment extends AssignmentToken  {
	
	public StringLeaf_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLeafAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringLeafRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getStringLeafAccess().getValueSTRINGTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getStringLeafAccess().getValueSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringLeaf ****************/


/************ begin Rule SymbolLeaf ****************
 *
 * SymbolLeaf:
 * 	name=ID;
 *
 **/

// name=ID
protected class SymbolLeaf_NameAssignment extends AssignmentToken  {
	
	public SymbolLeaf_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSymbolLeafAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSymbolLeafRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getSymbolLeafAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getSymbolLeafAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule SymbolLeaf ****************/


/************ begin Rule FloatLeaf ****************
 *
 * / *
 * StmtBlock:
 * 	(stmts+=SetExpression ';')*;
 * 
 * SetExpression returns Expression: 
 * 	MapExpression  ({Operation.left=current}name='=' right=MapExpression)*;
 * 
 * MapExpression returns Expression:
 * 	SlashDotExpression  ({Operation.left=current} name="->" right=SlashDotExpression)*;
 * 	 
 * SlashDotExpression returns Expression:
 * 	OrExpression  ({Operation.left=current} name="/." right=OrExpression)*;
 * 
 * OrExpression returns Expression:
 * 	AndExpression ({Operation.left=current} operator=("or"|"xor") right=AndExpression)*;
 * 
 * AndExpression returns Expression:
 * 	RelationalExpression ({Operation.left=current} operator="and" right=RelationalExpression)*;
 * 	
 * RelationalExpression returns Expression:
 * 	AdditiveExpression ({Operation.left=current} operator=("===" | "<>" | ">=" | "<=" | ">" | "<") right=AdditiveExpression)*;
 * 
 * AdditiveExpression returns Expression:
 * 	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;
 * 
 * MultiplicativeExpression returns Expression:
 * 	UnaryOrInfixExpression ({OperationCall.params+=current} name=("*" | "/") params+=UnaryOrInfixExpression)*;
 * 
 * UnaryOrInfixExpression returns Expression:
 * 	UnaryExpression | FunctionDefExpression; 
 * 
 * UnaryExpression returns Expression:
 * 	name=("not" | "-") params+=FunctionDefExpression;
 * 	
 * FunctionDefExpression returns Expression: 
 * 	FunctionExpression ({OperationCall.params+=current} ':=' body+=StmtBlock)* ; 
 * 
 * FunctionExpression returns Expression: 
 * 	(PrimaryExpression (({OperationCall.params+=current} 
 * 	name='[' (args+=SetExpression (',' args+=SetExpression)*)? ']')
 * 	)?);
 * 
 * PrimaryExpression returns Expression:
 * 	Literal | 
 * 	ObjectReference |
 * 	ParanthesizedExpression;
 * 
 * ParanthesizedExpression returns Expression:
 * 	name="(" exp=SetExpression ")";
 * 
 * Literal: BooleanLiteral | IntegerLiteral  | RealLiteral | StringLiteral;
 * 	
 * BooleanLiteral: 	bool=("True" | "False" );
 * IntegerLiteral: 	int=INT;
 * RealLiteral:    	real=REAL;
 * StringLiteral:   	string=STRING;
 * 
 * terminal REAL: ('0'..'9')* '.' ('0'..'9')*;
 * 
 * 
 * ObjectReference :  ContextDef | SymbolDef | DollarSymbolDef;
 * 
 * 
 * WildCardExp:
 * 	('_')+; 
 * 
 * 
 * ParamDef:
 * 	(name=SymbolDef ':') type=SymbolDef;
 * 
 * SymbolDef:
 * 	(prefix+=ID '::')* name=ID;
 * 
 * DollarSymbolDef :
 *  	'$' SymbolDef;
 *  	
 * ContextDef:
 * 	(path=ContextPath)? '`' def=SymbolDef;
 * 	
 * ContextPath:
 * 	path+=ID ('`' path+=ID);
 * 
 * //
 * //TypeDef:
 * //	BuiltInType | UserTypeDef; 
 * //	
 * //BuiltInType:
 * //	'integer' | 'boolean';
 * //
 * //UserTypeDef:
 * //	ref=[TypeDef];
 * //	
 * //	
 * 
 * 
 * //Alternatives H »» L
 * //Blank H_L
 * //BlankSequence H__L
 * //Cases
 * //Count
 * //DeleteCases
 * //MatchQ
 * //Pattern
 * //PatternTest H? L
 * * /FloatLeaf:
 * 	signed="-"? (a=INT "." b=INT | "." b=INT);
 *
 **/

// signed="-"? (a=INT "." b=INT | "." b=INT) / *
// StmtBlock:
// 	(stmts+=SetExpression ';')*;
// 
// SetExpression returns Expression: 
// 	MapExpression  ({Operation.left=current}name='=' right=MapExpression)*;
// 
// MapExpression returns Expression:
// 	SlashDotExpression  ({Operation.left=current} name="->" right=SlashDotExpression)*;
// 	 
// SlashDotExpression returns Expression:
// 	OrExpression  ({Operation.left=current} name="/." right=OrExpression)*;
// 
// OrExpression returns Expression:
// 	AndExpression ({Operation.left=current} operator=("or"|"xor") right=AndExpression)*;
// 
// AndExpression returns Expression:
// 	RelationalExpression ({Operation.left=current} operator="and" right=RelationalExpression)*;
// 	
// RelationalExpression returns Expression:
// 	AdditiveExpression ({Operation.left=current} operator=("===" | "<>" | ">=" | "<=" | ">" | "<") right=AdditiveExpression)*;
// 
// AdditiveExpression returns Expression:
// 	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;
// 
// MultiplicativeExpression returns Expression:
// 	UnaryOrInfixExpression ({OperationCall.params+=current} name=("*" | "/") params+=UnaryOrInfixExpression)*;
// 
// UnaryOrInfixExpression returns Expression:
// 	UnaryExpression | FunctionDefExpression; 
// 
// UnaryExpression returns Expression:
// 	name=("not" | "-") params+=FunctionDefExpression;
// 	
// FunctionDefExpression returns Expression: 
// 	FunctionExpression ({OperationCall.params+=current} ':=' body+=StmtBlock)* ; 
// 
// FunctionExpression returns Expression: 
// 	(PrimaryExpression (({OperationCall.params+=current} 
// 	name='[' (args+=SetExpression (',' args+=SetExpression)*)? ']')
// 	)?);
// 
// PrimaryExpression returns Expression:
// 	Literal | 
// 	ObjectReference |
// 	ParanthesizedExpression;
// 
// ParanthesizedExpression returns Expression:
// 	name="(" exp=SetExpression ")";
// 
// Literal: BooleanLiteral | IntegerLiteral  | RealLiteral | StringLiteral;
// 	
// BooleanLiteral: 	bool=("True" | "False" );
// IntegerLiteral: 	int=INT;
// RealLiteral:    	real=REAL;
// StringLiteral:   	string=STRING;
// 
// terminal REAL: ('0'..'9')* '.' ('0'..'9')*;
// 
// 
// ObjectReference :  ContextDef | SymbolDef | DollarSymbolDef;
// 
// 
// WildCardExp:
// 	('_')+; 
// 
// 
// ParamDef:
// 	(name=SymbolDef ':') type=SymbolDef;
// 
// SymbolDef:
// 	(prefix+=ID '::')* name=ID;
// 
// DollarSymbolDef :
//  	'$' SymbolDef;
//  	
// ContextDef:
// 	(path=ContextPath)? '`' def=SymbolDef;
// 	
// ContextPath:
// 	path+=ID ('`' path+=ID);
// 
// //
// //TypeDef:
// //	BuiltInType | UserTypeDef; 
// //	
// //BuiltInType:
// //	'integer' | 'boolean';
// //
// //UserTypeDef:
// //	ref=[TypeDef];
// //	
// //	
// 
// 
// //Alternatives H »» L
// //Blank H_L
// //BlankSequence H__L
// //Cases
// //Count
// //DeleteCases
// //MatchQ
// //Pattern
// //PatternTest H? L
// * /
protected class FloatLeaf_Group extends GroupToken {
	
	public FloatLeaf_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_Alternatives_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getFloatLeafRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// signed="-"?
protected class FloatLeaf_SignedAssignment_0 extends AssignmentToken  {
	
	public FloatLeaf_SignedAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getSignedAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("signed",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("signed");
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getFloatLeafAccess().getSignedHyphenMinusKeyword_0_0(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getFloatLeafAccess().getSignedHyphenMinusKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// a=INT "." b=INT / *
// StmtBlock:
// 	(stmts+=SetExpression ';')*;
// 
// SetExpression returns Expression: 
// 	MapExpression  ({Operation.left=current}name='=' right=MapExpression)*;
// 
// MapExpression returns Expression:
// 	SlashDotExpression  ({Operation.left=current} name="->" right=SlashDotExpression)*;
// 	 
// SlashDotExpression returns Expression:
// 	OrExpression  ({Operation.left=current} name="/." right=OrExpression)*;
// 
// OrExpression returns Expression:
// 	AndExpression ({Operation.left=current} operator=("or"|"xor") right=AndExpression)*;
// 
// AndExpression returns Expression:
// 	RelationalExpression ({Operation.left=current} operator="and" right=RelationalExpression)*;
// 	
// RelationalExpression returns Expression:
// 	AdditiveExpression ({Operation.left=current} operator=("===" | "<>" | ">=" | "<=" | ">" | "<") right=AdditiveExpression)*;
// 
// AdditiveExpression returns Expression:
// 	MultiplicativeExpression ({OperationCall.params+=current} name=("+" | "-") params+=MultiplicativeExpression)*;
// 
// MultiplicativeExpression returns Expression:
// 	UnaryOrInfixExpression ({OperationCall.params+=current} name=("*" | "/") params+=UnaryOrInfixExpression)*;
// 
// UnaryOrInfixExpression returns Expression:
// 	UnaryExpression | FunctionDefExpression; 
// 
// UnaryExpression returns Expression:
// 	name=("not" | "-") params+=FunctionDefExpression;
// 	
// FunctionDefExpression returns Expression: 
// 	FunctionExpression ({OperationCall.params+=current} ':=' body+=StmtBlock)* ; 
// 
// FunctionExpression returns Expression: 
// 	(PrimaryExpression (({OperationCall.params+=current} 
// 	name='[' (args+=SetExpression (',' args+=SetExpression)*)? ']')
// 	)?);
// 
// PrimaryExpression returns Expression:
// 	Literal | 
// 	ObjectReference |
// 	ParanthesizedExpression;
// 
// ParanthesizedExpression returns Expression:
// 	name="(" exp=SetExpression ")";
// 
// Literal: BooleanLiteral | IntegerLiteral  | RealLiteral | StringLiteral;
// 	
// BooleanLiteral: 	bool=("True" | "False" );
// IntegerLiteral: 	int=INT;
// RealLiteral:    	real=REAL;
// StringLiteral:   	string=STRING;
// 
// terminal REAL: ('0'..'9')* '.' ('0'..'9')*;
// 
// 
// ObjectReference :  ContextDef | SymbolDef | DollarSymbolDef;
// 
// 
// WildCardExp:
// 	('_')+; 
// 
// 
// ParamDef:
// 	(name=SymbolDef ':') type=SymbolDef;
// 
// SymbolDef:
// 	(prefix+=ID '::')* name=ID;
// 
// DollarSymbolDef :
//  	'$' SymbolDef;
//  	
// ContextDef:
// 	(path=ContextPath)? '`' def=SymbolDef;
// 	
// ContextPath:
// 	path+=ID ('`' path+=ID);
// 
// //
// //TypeDef:
// //	BuiltInType | UserTypeDef; 
// //	
// //BuiltInType:
// //	'integer' | 'boolean';
// //
// //UserTypeDef:
// //	ref=[TypeDef];
// //	
// //	
// 
// 
// //Alternatives H »» L
// //Blank H_L
// //BlankSequence H__L
// //Cases
// //Count
// //DeleteCases
// //MatchQ
// //Pattern
// //PatternTest H? L
// * /| "." b=INT
protected class FloatLeaf_Alternatives_1 extends AlternativesToken {

	public FloatLeaf_Alternatives_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_Group_1_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new FloatLeaf_Group_1_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// a=INT "." b=INT
protected class FloatLeaf_Group_1_0 extends GroupToken {
	
	public FloatLeaf_Group_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_BAssignment_1_0_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// a=INT
protected class FloatLeaf_AAssignment_1_0_0 extends AssignmentToken  {
	
	public FloatLeaf_AAssignment_1_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getAAssignment_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_SignedAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 1, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("a",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("a");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getFloatLeafAccess().getAINTTerminalRuleCall_1_0_0_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getFloatLeafAccess().getAINTTerminalRuleCall_1_0_0_0();
			return obj;
		}
		return null;
	}

}

// "."
protected class FloatLeaf_FullStopKeyword_1_0_1 extends KeywordToken  {
	
	public FloatLeaf_FullStopKeyword_1_0_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getFullStopKeyword_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_AAssignment_1_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// b=INT
protected class FloatLeaf_BAssignment_1_0_2 extends AssignmentToken  {
	
	public FloatLeaf_BAssignment_1_0_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getBAssignment_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_FullStopKeyword_1_0_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("b",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("b");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getFloatLeafAccess().getBINTTerminalRuleCall_1_0_2_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getFloatLeafAccess().getBINTTerminalRuleCall_1_0_2_0();
			return obj;
		}
		return null;
	}

}


// "." b=INT
protected class FloatLeaf_Group_1_1 extends GroupToken {
	
	public FloatLeaf_Group_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_BAssignment_1_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "."
protected class FloatLeaf_FullStopKeyword_1_1_0 extends KeywordToken  {
	
	public FloatLeaf_FullStopKeyword_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getFullStopKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_SignedAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 1, inst);
		}	
	}

}

// b=INT
protected class FloatLeaf_BAssignment_1_1_1 extends AssignmentToken  {
	
	public FloatLeaf_BAssignment_1_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatLeafAccess().getBAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new FloatLeaf_FullStopKeyword_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("b",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("b");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getFloatLeafAccess().getBINTTerminalRuleCall_1_1_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getFloatLeafAccess().getBINTTerminalRuleCall_1_1_1_0();
			return obj;
		}
		return null;
	}

}




/************ end Rule FloatLeaf ****************/

}
