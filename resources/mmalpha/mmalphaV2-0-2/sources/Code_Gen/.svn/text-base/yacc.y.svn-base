%{
 /*  file: $MMALPHA/sources/Code_Gen/yacc.y
   AUTHOR : Doran Wilde
   CONTACT : http://www.irisa.fr/api/ALPHA
   COPYRIGHT 1995,1996,1997,1998 by Brigham Young University,
              Provo, Utah; all rights reserved.
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   (see file : $MMALPHA/LICENSING).

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library(see file : $MMALPHA/LICENSING);
   if not, write to the Free Software Foundation, Inc., 59 Temple
   Place - Suite 330, Boston, MA  02111-1307, USA. */  
/* yacc.y
     COPYRIGHT
          Both this software and its documentation are


          Permission is granted to copy, use, and distribute
          for any commercial or noncommercial purpose under the terms
          of the GNU General Public license, version 2, June 1991
          (see file : LICENSING).
*/
#define GREETING "\
/* C-Code generated by Alpha Code Generator version 1.3.2 (Oct 28 1997) */\n\n"

#include <stdio.h>
#include <stdlib.h>
#include "../Write_Alpha/item.h"
#include "../Write_Alpha/itemprocs.h"
#include "../Write_Alpha/writeitem.h"
#include <polylib/polylib.h>
#include "node.h"
#include "nodeprocs.h"
#include "gen.h"

#define INDENT	3	/* must match gen.c */
#define FREE  1		/* must match gen.c */
#define FIXED 2		/* must match gen.c */
#define MAXRAYS 400	/* should match gen.c */

/*-----------------------------------------------------------------*/
/*                        Global Variables                         */
/*-----------------------------------------------------------------*/

extern	char *begcom, *endcom;		/* from gen.c */
int	lineNb;		/* Current input line number */
item	*alpha;		/* The alpha tree */
node	*alpha_node;	/* The (partial) alpha node tree */
int	G_dim = 0;	/* Dimension of the parameter space */

static  node *ID_List_Save=(node *)0, *Eqn_Decl=(node *)0, *Var_Decl=(node *)0;
static int case_flag = 0, Ecnt=0;
static int D_Save = 0;	/* the dimension of the current domain */
static int *G_val = (int *)0;	/* the values of the parameters */
static int V_Save = 0;	/* the size of the current vector */
static int I_Save = 0;	/* the position of the next element in the vector */

static context_info *Context = (context_info *) 0;	/* current context */

/*-----------------------------------------------------------------*/
/*                   Parser Support Procedures                     */
/*-----------------------------------------------------------------*/

%}
%token KW_system
%token KW_decl
%token KW_scalar
%token KW_integer
%token KW_boolean
%token KW_real
%token KW_equation
%token KW_case
%token KW_restrict
%token KW_var
%token KW_affine
%token KW_const
%token KW_binop
%token KW_unop
%token KW_if
%token KW_add
%token KW_sub
%token KW_mul
%token KW_div
%token KW_idiv
%token KW_mod
%token KW_eq
%token KW_le
%token KW_lt
%token KW_gt
%token KW_ge
%token KW_ne
%token KW_or
%token KW_and
%token KW_neg
%token KW_sqrt
%token KW_not
%token KW_domain
%token KW_pol
%token KW_matrix
%token KW_notype
%token KW_xor
%token KW_max
%token KW_min
%token KW_reduce
%token KW_depend
%token KW_dtable
%token KW_let
%token KW_loop
%token KW_use
%token KW_call
%token KW_true
%token KW_false
%token KW_pos_infinity
%token KW_neg_infinity

/*-----------------------------------------------------------------*/
/* I. General Specifications                                       */
/*-----------------------------------------------------------------*/
%token NUMBER
%token REAL
%token ID

%union	{ node *n; datatype t; item *i; int b; context_info *c; }
%type <n> Decl_List Decl 
%type <i> System_List System Let_Equations
%type <i> Equation_List Equation Exp_List Exp ID_item Constant 
%type <n> Pol_List Pol Matrix
%type <n> Number_List_List Number_List ID_List Domain 
%type <n> REAL ID
%type <t> Data_Type 
%type <i> Input_Decl Output_Decl Local_Decl Parameter
%type <b> Push_Clear_Case NUMBER

%start Top

%%
ID_item : ID
	{ $$ = Text("");
	  sprint_name($$->the.text.string,$1);
          free_node($1);
        }

/*-----------------------------------------------------------------*/
/* II. Function Specifications                                     */
/*-----------------------------------------------------------------*/
Top:   '{' System_List '}' 
	{ alpha =
	     Vsep3(0,"",
	       Vsep7(0, "",
	         Text(GREETING),
		 Text("#include <math.h>\n\n"),
		 Text("double atof();"),
		 Text("int    atoi();"),
		 Text("#define min(x,y) ((x)<(y)?(x):(y))"),
		 Text("#define max(x,y) ((x)>(y)?(x):(y))"),
		 Text("#define INFINITY 0x7fffffff\n\n")
	       ),
	       Vsep(0, "",
		 Text("#define boolean int")),
	       $2
	     );
	  YYACCEPT;
	}
|	System
	{ alpha =
	     Vsep3(0,"",
	       Vsep7(0, "\n",
	         Text(GREETING),
		 Text("#include <math.h>\n"),
		 Text("double atof();"),
		 Text("int    atoi();"),
		 Text("#define min(x,y) ((x)<(y)?(x):(y))"),
		 Text("#define max(x,y) ((x)>(y)?(x):(y))"),
		 Text("#define INFINITY 0x7fffffff")
	       ),
	       Vsep(0, "",
		 Text("#define boolean int")),
	       $1
	     );
	  YYACCEPT;
	}
|	Equation
	{ alpha = $1; YYACCEPT; }
|	Exp
	{ alpha = $1; YYACCEPT; };

System_List :
	System
            { $$ = $1; }
|	System_List System
	    { $$ = $1; };

System : KW_system '[' ID_item ',' Parameter ','
	 Input_Decl ',' Output_Decl ',' Local_Decl ','
         Let_Equations ']'
	{ $$ = Vsep6(0, "",
                   $5,		/* DEFINES for parameters */
	           Vspa(1),
	           Hsep3(0," ",
	             Text("void"),
                     $3,		/* System name */
                     Henc(INDENT,Text("("),Text(")"),
                       Hsep(0,",",	/* i/o variables */
	                 list_decls(alpha_node->the.sys.in,
	                            alpha_node->the.sys.out)
	               )
	             )
	           ),
                   $7,			/* Input declarations */
                   $9,			/* Output declarations */
                   Henc(INDENT, Text("{  "), Text("\n}"),
		     Vsep3(0, "",
                       $11,		/* Local declarations */
                       declare_indices(),  /* index decalarations */
                       $13		/* Equations */
                     )
	           )
	       );
	};

Parameter : Domain
	{   /* initialize the context */
	    Context = (context_info *) malloc (sizeof(context_info));
	    $$ = initialize_context($1, G_dim, G_val, Context);
            G_dim=Context->dom->Dimension;
	};

Input_Decl : '{' Decl_List '}'
        {  if ($2->the.list.first == (node *)0) 
            $$ = Text("/* no input variables */");
	  else		
            $$ = Vsep(0,"", convert_decl($2,0));
          alpha_node->the.sys.in = $2;
	};
  
Output_Decl : '{' Decl_List '}'
        { if ($2->the.list.first == (node *)0) 
            $$ = Text("/* no output variables */");
	  else
            $$ = Vsep(0, "", convert_decl($2,0));
          alpha_node->the.sys.out = $2;
	};

Local_Decl : '{' Decl_List '}'
        { if ($2->the.list.first == (node *)0) 
            $$ = Text("/* no local variables */");
	  else
            $$ = Vsep(0, "", convert_decl($2,0));
          alpha_node->the.sys.local = $2;
	};

Let_Equations: '{' Equation_List '}'
        { if (Ecnt < 2)
	     $$ = $2;
	  else
	     $$ = Vsep1(0, "", $2);
	}
|       KW_let '[' '{' Equation_List '}' ']'
        { if (Ecnt < 2)
	     $$ = $4;
	  else
	     $$ = Vsep1(0, "", $4);
	}
|       KW_let '[' Equation_List ']'
        { if (Ecnt < 2)
	     $$ = $3;
	  else
	     $$ = Vsep1(0, "", $3);
	};

Decl_List : Decl
        {  $$ = new_list($1); }

|       Decl_List ',' Decl
        {  $$ = add_to_list($1, $3); }

|       /* empty */
        {  $$ = new_list(0);};

Decl : KW_decl '[' ID ',' Data_Type ',' KW_scalar ']'
        {  $$ = new_node(decl);
           $$->the.decl.id = $3;
           $$->the.decl.type = $5;
           $$->the.decl.domain = (node *)0; }

|       KW_decl '[' ID ',' Data_Type ',' Domain ']'
        {  Polyhedron *P;
           node *p;
           int i;

           $$ = new_node(decl);
           $$->the.decl.id = $3;
           $$->the.decl.type = $5;
           $$->the.decl.domain = $7;
	   /* Declare the indices */
	   for (i=0, p=$7->the.dom.index->the.list.first ;
                i<($7->the.dom.dim-G_dim) ;
	        i++, p= p->next ) {  mark_index(p, FREE); }
            P = node2domain($7);
           compute_W(P, Context->dom, $7->the.dom.index, Context->index,
                     &($$->the.decl.l), &($$->the.decl.w) );
           Domain_Free(P);

       };

Data_Type : KW_integer
        {  $$=inttype; }

|       KW_boolean
        {  $$=booltype; }

|       KW_real
        {  $$=realtype; };

/*-----------------------------------------------------------------*/
/* III. Equation and Expression Specifications                     */
/*-----------------------------------------------------------------*/

Equation_List : Equation
	{  $$ = $1; Ecnt = 1; }

|	Equation_List ',' Equation
	{  $$ = add_to_ilist($1, $3); Ecnt++; }

|	/* empty */
	{  $$ = Text("/* empty */"); Ecnt=0; };

Equation : KW_equation '[' ID
	{ Eqn_Decl = get_decl($3,alpha_node); }
	',' Exp ']'
	{ item *name, *ref;
	  int dim;
          node *ident;
 
          name = Text("");
          sprint_name(name->the.text.string, Eqn_Decl->the.decl.id);
	  ident = identity_list(Eqn_Decl->the.decl.domain->the.dom.dim+1);
          do_substitution(Eqn_Decl->the.decl.domain->the.dom.index, ident, 0);
          ref = affine_list(Eqn_Decl->the.decl.domain->the.dom.index,
                                    ident, G_dim, 1);

          /* test for an infinite domain, requiring different processing */
          /* if (Eqn_Decl->the.decl.w) infinite=0; else infinite=1; */

          dim = Eqn_Decl->the.decl.domain->the.dom.dim - G_dim;

          if (dim==0)  /* scalar */
            $$ = Henc(0, Hsep2(0, "", name, Text("() = ")), Text(";"),
		             Hlis1(0, "", $6)
                 );
          else		/* array */
            $$ = Henc(0,
                    Hsep2(0,"",
                      name,
		      Henc(0, Text("("), Text(") = "), ref)
                    ), Text(";"),
                    Hlis1(0, "", $6)
                  );
          Eqn_Decl=(node *)0;
	  $$->prec = 0;
	}
|	KW_restrict '[' Domain
	{  /* update the context */
	   /* the context needs to include a list of fixed indices    */
           /* and the context domain.  The fixed indices are a subset */
	   /* of the indices of the context domain. */
	   $<c>$ = Context;	/* save pointer to old context on stack */
	   Context = control_domain($3, Context);
	}
	',' Equation ']'
	{  /* {...} : Block */

	   /* create item tree for code */
	   if (Context->body)
	     *(Context->body) = $6;  /* insert body into control code */
	   $$ = Context->code;
	   $$->prec = 0;

	   /* free context */
	   Context->code = (item *) 0;
	   free_node(Context->index);
	   Domain_Free(Context->dom);
	   free(Context);
	   ID_List_Save = (node *)0;

	   /* restore the old context */
	   Context = $<c>4;
	   index_restore(Context->index_stamp);
	}

|	KW_loop '[' Domain
	{  /* update the context */
	   /* the context needs to include a list of fixed indices    */
           /* and the context domain.  The fixed indices are a subset */
	   /* of the indices of the context domain. */
	   $<c>$ = Context;	/* save pointer to old context on stack */
	   Context = control_domain($3, Context);
	}
	',' Equation ']'
	{ /* {...} :: Block */
	   /* create item tree for code */
	   if (Context->body)
	     *(Context->body) = $6; /* insert body into control code */
	   $$ = Context->code;
	   $$->prec = 0;

	   /* free context */
	   Context->code = (item *) 0;
	   free_node(Context->index);
	   Domain_Free(Context->dom);
	   free(Context);
	   ID_List_Save = (node *)0;

	   /* restore the old context */
	   Context = $<c>4;
	   index_restore(Context->index_stamp);
	}

|	Let_Equations
	{ $$ = $1; };


Exp_List : Exp
	{  $$ = $1; }

|	Exp_List ',' Exp
	{  $$ = add_to_ilist($1, $3); }

|	/* empty*/
	{  $$ = (item *)0;};

Push_Clear_Case : {$$=case_flag; case_flag=0;};

Exp :   KW_restrict '[' Domain ',' Push_Clear_Case Exp ']'
	{ item *tmp, *item3;
          item3 = Hsep1(0, "",
		     domain2C(Eqn_Decl->the.decl.domain->the.dom.index, $3)
		  );
	  tmp = Hsep2(3, " ? ",
                   Henc(2, Text("( "), Text(" ) "), item3),
		   Henc(2, Text("( "), Text(" ) : "), $6)
		);
	  /* flag was pushed on symbol stack and cleared for Exp */
	  case_flag = $5;	/* restore case flag */
	  if (case_flag) $$ = tmp;
	  else $$ = Vsep2(0, "",
		       tmp,
                       Text("  ( printf(\"? restriction error\\n\"), exit(-1))")
		    );
	  $$->prec = 0;}

|       KW_case '[' {case_flag = 1;} '{' Exp_List '}' {case_flag = 0;} ']'
	{ /* check the types of all the expressions; if they are not restricts,
	     then dont bother with them */
	  $$ = Vsep2(2, "",
		  Vsep1(2,"",$5),
		  Text("  ( printf(\"? case error\\n\"), exit(-1))")
	       );
	  $$->prec = 0;}

|       KW_var '[' ID  ']'
	{ item *name;
          Var_Decl = get_decl($3,alpha_node);
          name = Text("");
	  sprint_name(name->the.text.string,Var_Decl->the.decl.id);
	  $$ = Hsep2(0, "",
                  Copy(name),
		  Henc(0, Text("("), Text(")"),
		     Hsep1(0, ",",
			id_list_n(Eqn_Decl->the.decl.domain->the.dom.index,
				  G_dim)
                     )
                  )
	       );
	  $$->prec = 10;}

|	KW_affine '[' KW_var '[' ID ']' ',' Matrix ']'
	{ item *name, *ref;

          Var_Decl = get_decl($5,alpha_node);
          name = Text("");
	  sprint_name(name->the.text.string,Var_Decl->the.decl.id);
	  do_substitution(Eqn_Decl->the.decl.domain->the.dom.index, $8, 0);
	  ref = affine_list(Eqn_Decl->the.decl.domain->the.dom.index,
                                    $8,G_dim,1);
	  $$ = Hsep2(0, "",
                  Copy(name),
		  Henc(0, Text("("), Text(")"), ref)
	       );
	  $$->prec = 7;
	}

|       Constant
        {  $$ = $1; }

|       KW_affine '[' Constant ',' Matrix ']'
        {  $$ = $3; }

|	KW_binop '[' KW_add ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " + ", check_prec($5,5), check_prec($7,5));
	    $$->prec = 5;}

|	KW_binop '[' KW_sub ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " - ", check_prec($5,5), check_prec($7,5));
	    $$->prec = 5;}

|	KW_binop '[' KW_mul ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " * ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_div ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " / ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_idiv ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " / ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_mod ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " % ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_eq ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " == ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_le ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " <= ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_lt ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " < ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_gt ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " > ", check_prec($5,4),check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_ge ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " >= ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_ne ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " != ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_or ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " || ", check_prec($5,1), check_prec($7,1));
	    $$->prec = 1;}

|	KW_binop '[' KW_xor ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " ^ ", check_prec($5,2), check_prec($7,2));
	    $$->prec = 2;}

|	KW_binop '[' KW_and ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " && ", check_prec($5,3), check_prec($7,3));
	    $$->prec = 3;}

|       KW_binop '[' KW_min ',' Exp ',' Exp ']'
        {   $$ = Henc(0, Text("min("), Text(")"),
                    Hsep2(0, ", ", check_prec($5,0), check_prec($7,0))
                 );
            $$->prec = 8;}

|       KW_binop '[' KW_max ',' Exp ',' Exp ']'
        {   $$ = Henc(0, Text("max("), Text(")"),
                    Hsep2(0, ", ", check_prec($5,0), check_prec($7,0))
                 );
            $$->prec = 8;}

|	KW_unop '[' KW_neg ',' Exp ']'
	{   $$ = Hsep2(0, "", new_text("-"), check_prec($5,7));
	    $$->prec = 7;}

|	KW_unop '[' KW_sqrt ',' Exp ']'
	{   $$ = Henc(0, Text("sqrt("), Text(")"), check_prec($5,0));
	    $$->prec = 0;}

|	KW_unop '[' KW_not ',' Exp ']'
	{   $$ = Hsep2(0,"",new_text("!"), check_prec($5,7));
	    $$->prec = 7;}

|	KW_call '[' ID ',' '{' Exp_List '}' ']'
	{   item *name;
	    name = Text($3->the.id.name);
	    $$ = Hsep2(0, "", Copy(name),
		       Henc(0, Text("("), Text(")"), Hsep1(0,",",$6)));
	}   

|	KW_if '[' Exp ',' Exp ',' Exp ']'
	{   $$ = Hsep5(4, " ",
		    Henc(0,Text("("),Text(")"), $3),
		    Text("?"),
		    Henc(0,Text("("),Text(")"), $5),
		    Text(":"),
		    Henc(0,Text("("),Text(")"), $7)
		 );
	    $$->prec = 0;};

Constant: KW_const '[' NUMBER ']'
        {  $$ = Number($3);
	   $$->prec = 10;
        }

|	KW_const '[' KW_pos_infinity ']'
	{  $$ = Text("INFINITY");
	   $$->prec = 10;
	}

|	KW_const '[' KW_neg_infinity ']'
	{  $$ = Text("-INFINITY");
	   $$->prec = 10;
	}

|	KW_const '[' KW_true ']'
        {  $$ = Number(1);
	   $$->prec = 10;
        } 

|	KW_const '[' KW_false ']'
        {  $$ = Number(0);
	   $$->prec = 10;
        } 

|	KW_const '[' REAL  ']'
	{  $$ = Hsep2(0,".",Number($3->the.rconst.value),
                            Number($3->the.rconst.fraction));
	   $$->prec = 10;
           free_node($3);
	};

/*-----------------------------------------------------------------*/
/* IV. Domain Specifications                                       */
/*       -- build and return a node tree for a domain              */
/*-----------------------------------------------------------------*/

Domain : KW_domain '[' NUMBER ',' '{' ID_List '}' 
        {  ID_List_Save = $6; D_Save = $3; V_Save = $3+2; }
        ',' '{' Pol_List '}' ']'
	  { $$ = new_node(dom);
	    $$->the.dom.dim = $3;
	    $$->the.dom.index = $6;
	    $$->the.dom.pol = $11; };

ID_List : ID
	{  $$ = new_list($1); }

|	ID_List ',' ID
	{  $$ = add_to_list($1, $3); }

|	/* empty */
	{  $$ = new_list(0) ;};

Pol_List : Pol
	{  $$ = new_list($1); }

|	Pol_List ',' Pol
	{  $$ = add_to_list($1, $3); }

|	/* empty */
	{  $$ = new_list(0);};

Pol : KW_pol '[' NUMBER ',' NUMBER ',' NUMBER ',' NUMBER ','
     '{' Number_List_List '}' ',' '{' Number_List_List '}' ']'
	{  $$ = new_node(pol);
           $$->the.pol.nb_constraints = $3;
           $$->the.pol.nb_equations = $7;
           $$->the.pol.constraints = $12;
           if ($3 != $12->the.list.count)
	      yyerror("Polyhedron nb_constraints doesn't agree.");
           free_node($16);
        };

/*-----------------------------------------------------------------*/
/* V.  Matrix Specifications                                       */
/*  -- build and return a node tree for a list of list of integers */
/*-----------------------------------------------------------------*/

Matrix : KW_matrix '[' NUMBER ',' NUMBER ',' '{' ID_List '}'
	{ V_Save = $5; }
	',' '{' Number_List_List '}' ']'
	{ $$ = $13; free_node($8); };

Number_List : NUMBER
	{  I_Save = 0;
	   $$ = new_node(vec);
	   $$->the.vec.dim = V_Save;
	   if (I_Save >= V_Save) yyerror("Vector has too many elements");
	   else
	   {  $$->the.vec.val = (int *)malloc(V_Save * sizeof(int));
	      $$->the.vec.val[0] = $1; I_Save++; }
	}

|	Number_List ',' NUMBER
	{  $$ = $1;
	   if (I_Save >= V_Save) yyerror("Vector has too many elements");
           else {  $$->the.vec.val[I_Save] = $3; I_Save++; }
	}

|	/* empty */
	{  $$ = new_node(vec);
	   $$->the.vec.dim = 0;
	   $$->the.vec.val = (int *) 0; };

Number_List_List : '{' Number_List '}'
	{  $$ = new_list($2); }

|	Number_List_List ',' '{' Number_List '}'
	{  $$ = add_to_list($1, $4); }

|	/* empty */
	{  $$ = new_list(0);};

%%
#include "lex.c"

/* DEFINED PREVIOUSLY             */
/* extern  FILE    *yyin, *yyout; */
/* extern  int     lineNb;        */
/* extern  item    *alpha;        */
FILE *ref = 0;		/* cross reference file */

int main(argc, argv)
int argc;
char *argv[];
{ int status, arg, i;

  yyin = stdin;
  yyout = stdout;
  yydebug = 0;
/*  malloc_debug(2); */
/*  malloc_verify(); */

  arg=1;
  while (arg < argc)
  {  if (*argv[arg]=='-')
     switch (argv[arg][1])
     {  case 'i':       /* input */
          arg++;
          yyin = fopen(argv[arg],"r");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
	  }
          break;
        case 'I':       /* input */
          arg++;
          yyin = fdopen(atoi(argv[arg]),"r");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
          }
          break;
        case 'o':       /* output */
          arg++;
          yyout = fopen(argv[arg],"w");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
          }
          break;
        case 'O':       /* output */
          arg++;
          yyout = fdopen(atoi(argv[arg]),"w");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
          }
          break;
        case 'd':       /* debug */
          yydebug = 1;
          break;
        case 'g':       /* debug for the resulting program */
          strcpy(begcom,"  ");
          strcpy(endcom,"  ");
          break;
        case 'p':
          arg++; i=0;
          G_val = (int *)malloc(12*sizeof(int));
          while (arg<argc && isdigit(*argv[arg]))
          { G_val[i] = atoi(argv[arg]);
            arg++; i++;
          }
          G_dim = i;
          arg--;
          break;
        default:
          fprintf(stderr, "? unknown switch %s\n", argv[arg]);
     }
     arg++;
  }

  alpha_node = new_node(sys);
  lineNb = 1;
  status = yyparse();
  if (status==1) /* parsing failed */ exit(1);
  print_item(alpha);
  fputc('\n', yyout);
  return 0;
}

yywrap()
{ return(1); }

yyerror(s)
char *s;
{  fprintf(stderr,"? line %d: %s\n", lineNb, s);
}
