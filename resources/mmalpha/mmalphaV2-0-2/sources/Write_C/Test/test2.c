/* system foobug2 */

/* C-Code generated by Alpha Code Generator version 1.2 */

#include <math.h>
typedef struct { int value;
		 int computed; } intvar;
typedef struct { int value;
		 int computed; } boolvar;
typedef struct { double value;
		 int computed; } realvar;
double atof();
int    atoi();

#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
#define INFINITY 0x7fffffff
#define SHR(x,y) ((x)/(double)(1<<(y)))
#define SHL(x,y) ((x)*(double)(1<<(y)))
#define EXP(x,y) pow((x),(y))
#define TRUNCATE(x) ((int)(x))
#define CEILING(x) ((int)(ceil(x)))
#define FLOOR(x) ((int)(floor(x)))
#define ROUND(x) ((int)(rint(x)))
#define FLOAT(x) ((double)(x))

/* parameters not fixed at compile time */

/* no input variables */

/* output variables */
intvar __a[4];
#define a(i)	__a[(i)-1]

/* local variables */
intvar __A[4];
#define A(i)	__A[(i)-1]

static int compute_a();

static int compute_A();

/* --let equations */
static int compute_A(i)
int i;
{
  intvar *tmp;
/* printf("Computing: A[%d]\n" ,i); */
  tmp = &(A(i));
  if (!tmp->computed) {
          tmp->value = ( -i+1>=0 || i-3>=0 )  ? ( 0 ) : 
         ( i-2==0 )  ? ( 1 ) : 
         ( printf("? case error\n"), exit(-1));
     tmp->computed = 1;}
  return tmp->value;
}

static int compute_a(i)
int i;
{
  intvar *tmp;
/* printf("Computing: a[%d]\n" ,i); */
  tmp = &(a(i));
  if (!tmp->computed) {
          tmp->value = compute_A(i);
     tmp->computed = 1;}
  return tmp->value;
}

int main()
{
   int i ;
   
   /* --inputs */
   /* --outputs */
   for (i=1; i<=4; i++)
   {  printf("a[%d]= %d\n", i, compute_a(i) );
   }
}
