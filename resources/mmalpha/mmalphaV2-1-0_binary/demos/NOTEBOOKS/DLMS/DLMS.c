/* system firr */

/* C-Code generated by Alpha Code Generator version 1.2 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
typedef struct { int value;
		 int computed; } intvar;
typedef struct { int value;
		 int computed; } boolvar;
typedef struct { double value;
		 int computed; } realvar;
double atof();
int    atoi();

#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
#define SHR(x,y) ((x)/(double)(1<<(y)))
#define SHL(x,y) ((x)*(double)(1<<(y)))
#define EXP(x,y) pow((x),(y))
#define TRUNCATE(x) ((int)(x))
#define CEILING(x) ((int)(ceil(x)))
#define FLOOR(x) ((int)(floor(x)))
#define ROUND(x) ((int)(rint(x)))
#define FLOAT(x) ((double)(x))

/* parameters */
#define N 3
#define M 10
#define D 5

/* input variables */
char __s_[32];
intvar __x[10];
#define x(n)	__x[(n)-1]
intvar __d[8];
#define d(n)	__d[(n)-3]

/* output variables */
intvar __res[8];
#define res(n)	__res[(n)-3]

/* local variables */
intvar __W[24];
#define W(n,i)	__W[(n)+8*(i)-3]
intvar __Y[32];
#define Y(n,i)	__Y[(n)+8*(i)+5]
intvar __E[8];
#define E(n)	__E[(n)-3]

static int compute_x(n)
int n;
{
  intvar *tmp;
printf("Computing: x[%d]\n" ,n);
  tmp = &(x(n));
  if (!tmp->computed) {
          printf("Input x[%d] =" ,n);
     gets(__s_);
     tmp->value = atoi(__s_);
     tmp->computed = 1;}
  return tmp->value;
}

static int compute_d(n)
int n;
{
  intvar *tmp;
printf("Computing: d[%d]\n" ,n);
  tmp = &(d(n));
  if (!tmp->computed) {
          printf("Input d[%d] =" ,n);
     gets(__s_);
     tmp->value = atoi(__s_);
     tmp->computed = 1;}
  return tmp->value;
}

static int compute_res();

static int compute_W();

static int compute_Y();

static int compute_E();

/* --let equations */
static int compute_W(n,i)
int n,i;
{
  intvar *tmp;
printf("Computing: W[%d,%d]\n" ,n,i);
  tmp = &(W(n,i));
  if (!tmp->computed) {
          tmp->value = ( -n+N+D-1>=0 )  ? ( 0 ) : 
         ( n-N-D>=0 )  ? ( compute_W(n-1,i) + compute_E(n-D) * compute_x(n-i-D) ) : 
         ( printf("? case error\n"));
     tmp->computed = 1;}
  return tmp->value;
}

static int compute_Y(n,i)
int n,i;
{
  intvar *tmp;
printf("Computing: Y[%d,%d]\n" ,n,i);
  tmp = &(Y(n,i));
  if (!tmp->computed) {
          tmp->value = ( i+1==0 )  ? ( 0 ) : 
         ( i>=0 )  ? ( compute_Y(n,i-1) + compute_W(n,i) * compute_x(n-i) ) : 
         ( printf("? case error\n"));
     tmp->computed = 1;}
  return tmp->value;
}

static int compute_E(n)
int n;
{
  intvar *tmp;
printf("Computing: E[%d]\n" ,n);
  tmp = &(E(n));
  if (!tmp->computed) {
          tmp->value = (compute_d(n) - compute_res(n)) / 32;
     tmp->computed = 1;}
  return tmp->value;
}

static int compute_res(n)
int n;
{
  intvar *tmp;
printf("Computing: res[%d]\n" ,n);
  tmp = &(res(n));
  if (!tmp->computed) {
          tmp->value = compute_Y(n,N-1);
     tmp->computed = 1;}
  return tmp->value;
}

int main()
{
   int i, n ;
   
   /* --inputs */
   for (n=1; n<=M; n++)
   {  printf("x[%d]= %d\n", n, compute_x(n) );
   }
   for (n=N; n<=M; n++)
   {  printf("d[%d]= %d\n", n, compute_d(n) );
   }
   /* --outputs */
   for (n=N; n<=M; n++)
   {  printf("res[%d]= %d\n", n, compute_res(n) );
   }
}
