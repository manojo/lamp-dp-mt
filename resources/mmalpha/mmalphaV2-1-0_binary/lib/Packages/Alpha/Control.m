(* file: $MMALPHA/lib/Package/Alpha.m
   AUTHOR : Patricia Le Moenner
   CONTACT : http://www.irisa.fr/api/ALPHA
   COPYRIGHT  (C) INRIA
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   (see file : $MMALPHA/LICENSING).

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library(see file : $MMALPHA/LICENSING);
   if not, write to the Free Software Foundation, Inc., 59 Temple
   Place - Suite 330, Boston, MA  02111-1307, USA.   
*)

BeginPackage["Alpha`Control`", {"Alpha`Domlib`",
				"Alpha`",
				"Alpha`Options`",
				"Alpha`Matrix`",
				"Alpha`Properties`",
				"Alpha`PipeControl`",
				"Alpha`Tables`",
				"Alpha`Normalization`",
				"Alpha`Substitution`",
				"Alpha`Semantics`",
				"Alpha`Schedule`"}]

(* $Id: Control.m,v 1.4 2010/04/10 19:52:14 quinton Exp $
 
 changelog: none
 *)

Control::usage = 
"Package. Contains the definition of functions related to control
signal generation: temporalCaseQ[], spatialCaseQ[], spaceTimeCase[],
spaceTimeDecomposition[], needsMuxQ[], makeMuxControl[],
makeAllMuxControl[], isControlEquQ[], controlVars[]."

Control::latex = 
"The \\texttt{Control} package contains functions related to 
the generation of control signal. These functions are\,:\n 
\begin{itemize}\n
\\item \\texttt{controlVars}.\n
\\item \\texttt{isControlEquQ},\n
\\item \\texttt{makeMuxControl},\n
\\item \\texttt{makeAllMuxControl},\n
\\item \\texttt{needsMuxQ},\n
\\item \\texttt{temporalCaseQ},\n
\\item \\texttt{spaceTimeCase},\n
\\item \\texttt{spaceTimeDecomposition},\n
\\item \\texttt{spatialCaseQ}.\n
\\end{itemize}
\n
These functions are used in the package \\texttt{ToAlpha0v2} 
to transform an \\alfa{} program into an \\alfa0{} program. 

The first function to be applied is \\texttt{spaceTimeDecomposition}.
This transformation replaces all case expressions found in
the program by two level case expressions. The outer case expression
is said to be {\\em spatial}, as the conditions which separate the
branches of the case are on processor numbers. The inner case
expressions are said to be {\\em temporal}, as the conditions which
separate the branches of the cases are on time indexes. 

The \texttt{temporalCaseQ} and \texttt{spatialCaseQ}
predicates allows one to detect temporal and spatial cases
respectively. 

The second function to be applied is \texttt{makeBinaryCases}.
Its goal is the replace non binary temporal case expressions 
by binary ones. This function is still fragile...

The third function to be applied is \texttt{makeAllMuxControl}.
Each temporal case expression is transformed into a multiplexer
which is controled by a control signal which is generated by 
this function. 

";

makeOneMuxControl::usage =
"makeOneMuxControl[sys, tpos, spos, var, options] generates a multiplexer
for the definition of var.";

makeOneMuxControl::latex = 
"\\texttt{makeOneMuxControl[ sys, tpos, spos, var, options]}\n
generates a multiplexer for the definition of var.";

makeAllMuxControl::usage =
"makeAllMuxControl[sys, tpos, spos, options] generates multiplexers 
and their control variables for all the variables in the system sys 
needing it. The system sys must be in space/time form 
(see spaceTimeDecomposition). The modified system
is returned. makeAllMuxControl[tpos, spos, options], applies to $result 
and modifies it."

temporalCaseQ::usage =
"temporalCaseQ[sys, expr, post, poss] checks whether or 
not the case expression expr of sys is a temporal case 
(all alternatives are defined over the same spatial domain.) 
post is the list of positions of temporal indices and
poss is  the list of positions of spatial indices.
WARNING: This function checks pure temporal case (no condition 
involving space can change in the branches of the case)";

spatialCaseQ::usage =
"spatialCaseQ[sys, expr, post, poss] checks whether or not the
case expression expr of sys is a spatial case (i.e.,
can be rewritten using conditions on spatial indices only). 
post is the list of positions of
temporal indices, and poss is the list of positions of spatial
indices.";

spaceTimeCase::usage =
"spaceTimeCase[sys, varname, tpos, spos] unrolls the normalized 
case-based definition of local variable varname to a double case 
spatial then temporal. spaceTimeCase[varname, tpos, spos] applies to 
$result and modifies it."

makeSTCase::wrongArg=
"a restriction is probably missing in a case."

spaceTimeDecomposition::usage =
"spaceTimeDecomposition[sys,  tpos, spos] transforms all the local 
variables of sys into their space-time case form.
spaceTimeDecomposition[varname, tpos, spos] applies to $result
and modifies it."

needsMuxQ::usage =
"needsMuxQ[exp] returns True if expr of $result needs a multiplexer, 
False otherwise."

makeMuxControl::usage =
"makeMuxControl[var, ctrlVar, tpos, spos] builds the mux control
variables for variable var. It is restricted to cases with two branches. 
WARNING: DOES not check that the temporal cases are binary.";

isControlEquQ::usage = 
"isControlEquQ[equation] checks that equation is a control variable equation.
Such an equation is space/time case expression with two branches equal to 
True and False."

controlVars::usage = 
"controlVars[sys] returns the list of control variables in system sys. 
controlVars[] applies to $result. A control variable
is defined by a space/time case with two time branches equal to True
and False."

makeBinaryCases::usage = 
"makeBinaryCases[ sys, var, opts ] replaces in the definition of 
var, all case statements with more than 2 branches by binary 
cases. makeBinaryCases[ var, opts ] does the same to $result."; 

Begin["`Private`"];


(* 
 There are mainly two parts in this file: 
 The first part is the space/time decomposition.
 The second part is the multiplexer generation.
*)


(*----------------------------------------------------------*)
(*                 spaceTimeDecomposition                   *)


(* See the usage. 
   Basically this function calls spaceTimeCase[] on all the local
   variables.
*)

Clear[spaceTimeDecomposition];

Options[spaceTimeDecomposition] = 
  {debug->False, verbose->False, exceptions->{}};
  
spaceTimeDecomposition[ timeIndexPos:{_Integer..},
  spaceIndexPos:{_Integer...},
  opts:___Rule 
]:=
  (Alpha`$program = Alpha`$result;
   Alpha`$result = spaceTimeDecomposition[Alpha`$result,
					  timeIndexPos,
					  spaceIndexPos, opts]);

spaceTimeDecomposition[
  sys_Alpha`system,
  timeIndexPos:{_Integer..},
  spaceIndexPos:{_Integer...},
  opts:___Rule 
]:=
Catch[
  Module[{s,localvars,i,uses,outuses,varEx},
    If[ spaceIndexPos == {}, 
      spaceTimeDecomposition::noSpace = "space index should not be empty";
      Throw[ Message[ spaceTimeDecomposition::noSpace ] ]
    ];
    s=sys;

    localvars = Map[First,sys[[5]]];

    (* We do not consider outputs of uses *)
    uses = Cases[ sys[[6]], use[___] ];
    outuses = Apply[ Union, Map[ Part[#1,5]&, uses ] ];
    localvars = Complement[ localvars, outuses ];
(*
    Print["outuses : ", outuses ];
    Print["localvars : ", localvars ];
*)
    (* Remove varExceptions from the list *)
    varEx = exceptions/.{opts}/.Options[spaceTimeDecomposition];
    If[ varEx=!={}, Print["Exceptions: ", varEx] ];
    localvars = Complement[ localvars, varEx ];

(*
    Print["Local vars: ", localvars ];
*)
    For[i=1,i<=Length[localvars],i=i+1,
      s = spaceTimeCase[s,
            localvars[[i]],
            timeIndexPos,
            spaceIndexPos, opts]
    ];
    s
  ]

];
spaceTimeDecomposition::args = "wrong parameters";
spaceTimeDecomposition[___]:=Message[spaceTimeDecomposition::args]

(*----------------------------------------------------------*)
(*                        spaceTimeCase                     *)
 

(* See the usage. 
   Basically this function looks for Alpha`cases, 
   and applies to them makeSTCase.  *)

Options[ spaceTimeCase ] = 
  {debug->False,verbose->False};
Clear[spaceTimeCase];

(* To save $result, in case of undo *)
spaceTimeCase[varName_String,
  timeIndexPos:{_Integer..},
  spaceIndexPos:{_Integer..}, opts:___Rule
] :=
(Alpha`$program = Alpha`$result;
 Alpha`$result = 
  spaceTimeCase[Alpha`$result,
                varName,
                timeIndexPos,
                spaceIndexPos, opts]);

(* Proper definition *)
spaceTimeCase[sys_Alpha`system,
	      varName_String,
	      timeIndexPos:{_Integer..},
	      spaceIndexPos:{_Integer..}, opts:___Rule 
]:=
Module[{def = getDefinition[sys, varName], 
  dbg = debug/.{opts}/.Options[ spaceTimeCase ],
  vrb = verbose/.{opts}/.Options[ spaceTimeCase ], result },

  If[ vrb||dbg, Print["====    Calling spaceTimeCase on definition of : ", varName] ];

  (* Check definition *)
  If[def === {},
     (Print["Variable ", def, " is not defined...."];
      Return[sys])];

  (* Expression must be a case expression *)
  If[!MatchQ[def, _Alpha`case], (Return[sys])];

  If[ dbg, Print[ show[ getEquation[ varName ], silent -> True ] ] ];

  (* Call makeSTCase *)
  Check[
    result =
      Alpha`case[
        makeSTCase[
          sys,
          getDeclarationDomain[sys, varName],
          def,
          timeIndexPos,
          spaceIndexPos,
          opts, debug -> dbg ]
    ],
    spaceTimeCase::errormakeSTCase = "error while calling makeSTCase on var `1`. System unchanged.";
    Message[ spaceTimeCase::errormakeSTCase, varName ];
    Return[ sys ]
  ];

  If[ dbg, Print["Result: ", show[ result, silent -> True ] ] ]; 

  replaceDefinition[sys, varName, result]
];
spaceTimeCase[___]:=Message[spaceTimeCase::params];

(*----------------------------------------------------------*)
(*                          makeSTCase                       *)

(* Returns a list of restrictions corresponding to a space-time case,
   as described in Catherine Dezan s thesis, p. 57 and following.

The ST form consists of one or two levels of case:

- the first level is a spatial case, i.e. the projections on the space
indices of the domains of the branches are distinct.

- if present, the second level is a temporal case, i.e.  the
projections on the space indices of the domains of the branches are
all the same.

If the case there was already a temporal case, then a second level is added
anyway, consisting of a case with one single branch whose restriction
is the projection on the space indices. This is a difference with
Catherine Dezan s thesis. *)

Clear[makeSTCase];

(* Only one branch. This branch must have a restriction  *)
makeSTCase[sys:_system,
  LHSdomain:_domain,
  caseOp: case[{r1_restrict}],
  timeIndexPos: {_Integer..},
  spaceIndexPos: {_Integer..}, opts:___Rule 
]:= 
Catch[
  Module[{dbg, calc, expD, intersec },

  dbg = debug/.{opts}/.Options[ spaceTimeDecomposition ];
  If[ dbg, Print["Calling makeSTCase, one branch only" ] ];

  (* Find expression domain of the restriction *)
  Check[ 
    expD = expDomain[sys,r1], 
    makeSTCase::error1 = "error while calling expDomain";
    Throw[ Message[ makeSTCase::error1 ] ] 
  ];

  (* Compute intersection of LHS domain and expression domain. *)
  intersec = DomIntersection[ expD, LHSdomain ];

  If[ dbg, Print["LHSdomain: ", ashow[ LHSdomain, silent -> True ] ] ];
  If[ dbg, Print["expDomain: ", ashow[ expD, silent -> True ] ] ];

  If[ dbg,
    If[ !DomEqualQ[ expD, intersec ], 
      Print["expDomain and its intersection with the variable domain are not equal"]; 
      Print["expDomain: ", ashow[ expD, silent->True] ]; 
      Print["intersec: ", ashow[ intersec, silent->True] ]; 
    ];
  ];

  (* Replace the restriction by the intersection of the 
    expression domain and the domain of the LHS *)
  calc = {normalize[ restrict[ intersec, r1[[2]] ] ]};

  If[ dbg, Print[ "Result of makeSTCase: ", 
    Print["11111111111"];
    ashow[calc[[1]], silent->True] ] 
  ]; 

  calc
  ]
];
  
(* More than one branch: see Dezan s thesis pp 57-58.

The algorithm is the following (not exactly that of Catherine).
(To understand it, go through it with n=2 first)
 
1/ let the initial list of restrictions be res = {}.
    put aside r, the first restriction, let d0 be its domain.

2/ space/time decompose the n-1 last restrictions, yielding
     n-1 case branches of the form
        di : expi
    where the expi are time cases, spatially disjoint.
 
3/ For each of these branches,
    31/ compute dp the intersection of its space projection 
        with that of d0.
    32/ If this intersection is empty
        then add di:expi to the list of restrictions 
             and keep d0 unchanged for the next round
             else 
               compute d, the intersection of d0 and di 
                  (see Dezan thesis p57)
               compute ddi = di\d   (\ means set difference)
               compute dinter = d0 inter d
               compute dinteri = di inter d
               Now d and ddi have disjoint space projections
	       so we may add to the restriction list 
	         d : case
	              dinteri: expi;
		      dinter:  exp;
	             esac;
               and possibly also (if ddi is not empty)
                 ddi : expi ;   
	       let d0 = d0\d for the next branch.

4/ Finally, if d0 is not empty, 
          add d0:exp to the list of restrictions
   (because now d0 = d0(initial) \ d1 \ d2 \ d3...)
*)

(* Called when the length of the case is greater than 1 *)
(* This function cannot be called if a restriction is missing... *)
makeSTCase[
  sys:_system,
  LHSdomain:_domain,
  caseOp: case[{_Alpha`restrict..}] /; Length[caseOp[[1]]] > 1,
  timeIndexPos:{_Integer..},
  spaceIndexPos:{_Integer..}, opts:___Rule 
]:=
Module[
  {paramdom,strestrs,res,r,initdom,d0,exp,i,dbg,
   ri,initdomi,expi,di,spaced,spacedi,dp,d,sd,ddi,dinter,dinteri,indexes},
   dbg = debug/.{opts}/.Options[ spaceTimeDecomposition ];

  paramdom = sys[[2]];

  If[ dbg, Print["Calling makeSTCase, number of branches > 1"]];

  If[ dbg, 
    Print[ 
      "Remove first branch, which is:\n",
      ashow[ Delete[ caseOp, {1,1} ], silent -> True ], 
      "\nTime index: ", timeIndexPos, 
      "\nSpace index: ", spaceIndexPos ]
    ];

  (* Recursive call to makeSTCase *)
  If[ dbg, 
    Print["---------- Recursive call to makeSTCase..."]
  ];

  strestrs = 
    makeSTCase[sys,
      LHSdomain,
      Delete[ caseOp, {1,1} ],
      timeIndexPos,
      spaceIndexPos, opts
  ];

  If[ dbg, 
    Print["---------- Returning from makeSTCase"]
  ];


(*
  If[ dbg, Print["strestrs : "]; Map[ ashow[#,silent->True]&, strestrs ] ];
  If[ dbg, Print["strestrs = ", strestrs ]];
*)

  (* Correction by P. Quinton, Apr 9/2001 *)
  (* When the domain of the restriction is empty, strestrs contains
     an empty expression which should be removed *)
  strestrs = Complement[ strestrs, {{}} ];
(*
  If[ dbg, Print["strestrs = ", strestrs ]];
*)

  res = {}; (* res is ? *)
  r = caseOp[[1]][[1]] (* r is the first branch of the restr *);
  If[ dbg, Print["First branch of the restriction, r: ", ashow[r, silent->True ] ] ];

  initdom = expDomain[sys,r]; (* domain of the first branch *)
  If[ dbg, Print["initidom is empty: ", DomEmptyQ[initdom] ] ]; 
  d0 = addParameterDomain[ 
         DomIntersection[ LHSdomain, initdom],
         paramdom 
       ];
  If[ dbg, Print["Initial domain of the first branch, d0: ", 
    ashow[ d0, silent->True ] ] ]; 

  exp = r[[2]]; (* Take the expression of the first branch of the case *)
  If[ dbg, Print["Expression of the first branch of the case, exp: ", ashow[ exp, silent->True ] ] ]; 

(*
  If[ Length[strestrs]>=2, 
    Print[ "------------ Warning -------------" ] ];
*)

  (* 
    Iteration process...
   *)

  For[i=1, i<=Length[strestrs], i=i+1,

    If[dbg, Print[" ------ Iteration number: ", i]];

    ri = strestrs[[i]];

    (* Show the list of restrictions *)
    If[ dbg, Print["List of restrictions, strestrs= ", 
      Map[ ashow[#,silent->True]<>"\n"&, strestrs ] ]; 
      Print["Restriction number i is ri: ", ashow[ri,silent->True] ], Null ];

(*    If[ ri == {}, res, *)

    (* Get domain of expression ri *)
    initdomi = 
      Check[ expDomain[sys,ri], 
        Print["Error while calling expDomain on :\n",ri];
        Throw[Message[expDomain::error];sys] 
    ]; 

    expi = ri[[2]]; 

    If[ dbg, Print["Expression i, expi: ", ashow[ exp, silent->True ] ] ]; 
    di = addParameterDomain[ 
           DomIntersection[ LHSdomain, initdomi],
           paramdom 
    ];
    If[ dbg, Print["Domain i, di: ", ashow[ di, silent->True ] ] ]; 

    (* FIXIT: should be outside the loop... *)
    (* Project domain d0 along time index *)
 (*
    spaced = canonicalProjection[d0, timeIndexPos];
  *)

    If[ dbg, Print["d0 : ", 
      ashow[ d0, silent->True ] ] ]; 
    spaced = DomProject[d0, Drop[d0[[2]],1] ];
    If[ dbg, Print["Projection of d0, spaced: ", 
      ashow[ spaced, silent->True ] ] ]; 

    (* Project domain di along time index *)
 (*
    spacedi = canonicalProjection[di, timeIndexPos];
  *)
    spacedi = DomProject[di, Drop[di[[2]],1] ];
    If[ dbg, Print["Space projection of di, spacedi: ", 
      ashow[ spacedi, silent->True ] ] ]; 

    dp = DomIntersection[spaced,spacedi];
    If[ dbg, Print["Intersection of spaced and spacedi dp: ", 
      ashow[dp,silent->True]], Null ];

    If[DomEmptyQ[dp],	 

      (* ** *)
      If[ dbg, Print["dp is empty"], Null ];
      res = Append[res, ri]
    ,

      (* else *)
      If[ dbg, Print["dp is not empty"], Null ];
      d = addLinSpace[dp (* add infinite temporal inds *),
            MapThread[List,
              {timeIndexPos,
               Part[d0[[2]],
               timeIndexPos ] } ] 
          ];

      If[ dbg, Print["Domain dp, extended to all time, d : ", show[d,silent->True]] ];

      (* Was removed because of a problem in DomConvex... *)
      sd = convexize[ DomIntersection[DomUnion[d0, di], d]]; 
      (*      sd = DomIntersection[ DomUnion[ d0, di ], d ];  *)
      If[ dbg, Print["(d0 U di) Inter d is, sd : ", ashow[d,silent->True]] ];

      (* Was removed because of a problem in DomConvex *)
      ddi = convexize[DomDifference[di,d]]; 

      ddi = DomDifference[di,d];
      dinter = DomIntersection[d0,d];
      dinteri = DomIntersection[di,d];

      If[ dbg, Print["ddi is empty: ", DomEmptyQ[ddi] ] ];

      If[ dbg, Print["------ i: ", i ] ]; 
      res = 
        Join[res, 
          {Alpha`restrict[sd,
             normalize[
               Alpha`case[
                 {Alpha`restrict[dinter, exp],
                  Alpha`restrict[dinteri, expi]} 
               ] 
             ] 
           ]
          },
          If[DomEmptyQ[ddi], {}, {Alpha`restrict[ddi,expi]}]
     ];

     (* Removed because of a probleme in DomConvex 
     d0 = convexize[DomDifference[d0,d]]; *)
     If[ dbg,
       Print["d0: ", show[d0, silent->True] ];
       Print["d: ", show[d0, silent->True] ];
     ];
     d0 = DomDifference[d0,d]; 

     If[ dbg,
       Print["Diff between d0 and d: ", show[d0, silent->True] ];
     ];

   ]; (* End If[DomEmptyQ[dp] *)

   If[ dbg, Print[" --------- i: ", i ] ];

 ]; (* For *)

  res = Join[If[DomEmptyQ[d0], {}, {Alpha`restrict[d0,exp]}], res];
  res
];

makeSTCase[___] := Message[makeSTCase::wrongArg];

(*            MULTIPLEXER GENERATION             *)

(* i.e add control variables to a space-time case *)

(* ---------------------makeAllMuxControl-----------------

  This is a new function by Florent. It applies to a whole system, not
  to a single equation, and handles multiple
  space branches properly.
*)

Options[makeAllMuxControl] = 
  {verbose->False, initZeroReg->True };

Clear[makeAllMuxControl];
makeAllMuxControl[timeIndexPos:_List,
                  spaceIndexPos:_List, 
                  options:___Rule] :=
Module[{},
  $program = $result;
  $result = 
  makeAllMuxControl[ 
    $result,
    timeIndexPos,
    spaceIndexPos,
    options] 
];

(* And now for the real thing. The algorithm is very sequential: just
   scan the equations, looking for space-time cases (loop on i). When
   one is found, scan all of its space branches and build the control
   for each of them (loop on j). One control variable is added for
   each of the space branches. The equations of the new system are
   built incrementally in equList, its declarations in declList.*)
makeAllMuxControl[ sys:_system,
		   timeIndexPos:_List,
		   spaceIndexPos:_List,
                   opts:___Rule] :=
Catch[
Module[ { equList, declList, i, dbg, res, rank, equsys, localVars, 
          newdecls, newequs, declsys, uses, outuses },

  dbg = debug /. {opts} /. Options[ makeAllMuxControl ]; 
  
  (* Get list of local vars *)
  localVars = getLocalVars[ sys ]; 
  (* We do not consider outputs of uses *)
  uses = Cases[ sys[[6]], use[___] ];
  outuses = Apply[ Union, Map[ Part[#1,5]&, uses ] ];
  localVars = Complement[ localVars, outuses ];

(*
  localVars = {"X"};
*)
  Catch[
    res = 
    Map[
      Check[
        res = makeOneMuxControl[ sys, timeIndexPos, spaceIndexPos, #1 , 
        opts],
        Throw[Null]
      ]&, 
      localVars
    ];
  ]; 

  If[ res === Null, Throw[ Null ] ];

  (* Now, we introduce the resulting declarations and 
     equations into the system *)
  For[ declsys = sys[[5]]; 
       equsys = sys[[6]];
       i=1, 
       i<=Length[res], i++, 

    (* Get i-th result *)
    {newdecls, newequs} = res[[i]];


    (* Get the rank of the i-th equation *)
    rank = Position[ equsys, equation[ localVars[[i]], ___ ] ];
    rank = First[ First[ rank ] ]; 

    (* Join the new declaration to the previous ones *)
    declsys = Join[ declsys, newdecls ];

(*
    ashow[Take[ equsys, rank-1 ]];
    ashow[ equList ]; 
    ashow[Drop[ equsys, rank ]];
*)
    (* Same for new equations *)
    If[ newequs =!= {},
      equsys = 
        Join[ Take[ equsys, rank-1 ], 
          newequs, 
          Drop[ equsys, rank ]
      ]
    ];

(*
    ashow[ equsys ]; 
*)
];


  (* Return the new system *)
  system[ sys[[1]], sys[[2]], sys[[3]], sys[[4]], declsys, equsys ]

] (* End Module *)
];

makeAllMuxControl[___]:=Message[makeAllMuxControl::args];

(* 
  This functions replaces all non binary time case expressions
  by binary ones...
*)
Clear[makeBinaryCases]; 
Options[ makeBinaryCases ] = { debug -> False, verbose -> False }; 

(* 
  This case is when $result is assumed, and do it for all 
  variables 
*)
makeBinaryCases[ opts:___Rule ]:=
Module[ {},
  $program = $result;
  $result = 
    Check[ makeBinaryCases [ $result, opts ],
      $result
    ];
];

(* 
  This case is when system is specified, and for all 
  variables
*)
makeBinaryCases[ sys:_system, opts:___Rule ] :=
Catch[
  Module[ { positions, newsystem, symbol, dbg, verb },

    dbg = debug/.{opts}/.Options[ makeBinaryCase ];
    verb = verbose/.{opts}/.Options[ makeBinaryCase ];

    newsys = sys; 
    positions = Position[ sys, case[{_,_,__}], Infinity];
    If[ dbg, Print[ "Position of cases: ", positions ] ];
    While[ positions =!= {},
      symbol = getPart[ newsys, Take[ positions[[1]], 2 ] ][[1]];
      newsys = makeBinaryCases[ newsys, symbol, opts ];
      positions = Position[ newsys, case[{_,_,__}], Infinity];
      If[ dbg, Print[ "Position of cases: ", positions ] ];
    ];
    newsys
  ]
];

(* 
  This case is when $result is assumed, and one variable
  only
*)
makeBinaryCases[ varname:_String, opts:___Rule ]:=
Module[ {},
  $program = $result;
  $result = 
    Check[ makeBinaryCases [ $result, varname, opts ],
      $result
    ];
];

(* 
  This case is when system is specified and one variable
*)
makeBinaryCases[ sys:_system, varname:_String, opts:___Rule ]:=
Catch[
  Module[ { dbg, verb, poseq, poscase, equ, positions, casexp, 
            nbbranches, newsym, newdom, newsys },
    dbg = debug/.{opts}/.Options[ makeBinaryCase ];
    verb = verbose/.{opts}/.Options[ makeBinaryCase ];

    Check[ 
      equ = getEquation[ sys, varname ],
      makeBinaryCases::noequ = "no equation for var `1`"; 
      Throw[ Message[ makeBinaryCases::noequ, varname ] ]
    ];

    (* Get position of equation *)
    poseq = Position[ sys, equ ]; 

    (* Get positions of case expressions in equ, with 
       more than 2 branches *)
    positions = Position[ equ, case[{_,_,__}], 4 ]; 

    (* Do not change system *)
    If[ Length[ positions ] === 0, Return[ sys ] ];
  
    (* Otherwise, change it *)
    poscase = Join[ poseq[[1]], positions[[1]] ];
    If[ dbg, Print[ "Position of the case statement: ", poscase ] ];

    (* Compute domain of case expression *)
    casexp = getPart[ sys, poscase ]; 
    If[ dbg, Print[ "Case expression :\n" ]; ashow[ casexp ] ];

    (* Remaining part of the case expression *)
    restcase = case[ Drop[ casexp[[1]], 1 ] ];
    If[ dbg, Print[ "Rest of case:\n", ashow[ restcase, silent -> True ] ] ];

    (* New symbol name *)
    newsym = equ[[1]]<>"c1";

    (* Compute domain of restcase to add a declaration *)
    Check[
      newdom = expDomain[ sys, restcase ],
      Throw[ Null ]
    ];
    If[ dbg, Print["Definition domain: "];ashow[ newdom ] ];

    (* Compute old equation, where case expression has been 
       replaced *)
    oldequ = 
      ReplacePart[ equ,
        case[ { casexp[[1,1]], 
                restrict[ newdom, var[ newsym ] ] } ], 
        positions[[1]] 
      ];
    If[ dbg, Print["Old equation: "];ashow[ oldequ ] ];

    (* Get type of new expression *)
    type = getDeclaration[ sys, varname ][[2]];

    (* Build its declaration *)
    declaration = decl[ newsym, type, newdom ];

    (* Build new equation *)
    newequ = equation[ newsym, restcase ];

    (* Build new system *)
    newsys = system[ sys[[1]], sys[[2]], sys[[3]], 
      sys[[4]], Append[ sys[[5]], declaration ], 
      sys[[6]]];

    newsys = ReplacePart[ newsys, oldequ, poseq[[1]] ];
    newsys = Insert[ newsys, newequ, poseq[[1]] ]

  ]
];

makeBinaryCases[ ___ ] := Message[ makeBinaryCases::params ]; 

(* 
  This function creates a mux for one equation.
  Starting from a system, and a var name, it generates
  a set of declarations, and a set of equations, that
  must be added to the previous system.    
*)
Clear[makeOneMuxControl];
Options[makeOneMuxControl] = 
  {debug -> False, verbose -> False, initZeroReg -> True};
makeOneMuxControl[ 
  sys:_system, 
  timeIndexPos:{__Integer}, 
  spaceIndexPos:{__Integer}, 
  var:_String,
  opts:___Rule] :=
Catch[
  Module[ {equ, rhs, vardom, declist, dbg, verb, zeroReg,
           ctldom, domTrue, domFalse, muxSignal, muxCtrl,
           newdecl, newequations, branches, tempdom1, tempdom2,
           posbranch, casexpr, poseq },

    dbg = debug/.{opts}/.Options[ makeOneMuxControl ];
    verb = verbose/.{opts}/.Options[ makeOneMuxControl ];
    zeroReg = initZeroReg/.{opts}/.Options[ makeOneMuxControl ];

    newdecl = {};
    newequations = {};

    Check[ 
      equ = getEquation[ sys, var ],
      makeOneMuxControl::noequ = "no equation for var `1`"; 
      Throw[ Message[ makeOneMuxControl::noequ, var ] ]
    ];


    (* Get position of equation for future use *)
    poseq = Position[ sys, equ ];
    If[ dbg, Print[ "Position of equation: ", poseq ] ]; 

    Check[ 
      decllist = getDeclaration[sys, var],
      makeOneMuxControl::nodecl = "no declaration for var `1`"; 
      Throw[ Message[ makeOneMuxControl::nodecl, var ] ]
    ];
    If[MatchQ[equ,use[___]],
         (* if the variable is defined by a use we do not generate control signal *) 
         If[verbose,Print["No control signal generated for variable ",var]]];

    (* Get the domain of var declaration *)
    vardom = decllist[[3]];

    If[ dbg, Print["  Equation :\n", ashow[ equ, silent -> True ] ] ];

    (* Get rhs of equation *)
    rhs = equ[[2]];

    (* Checks whether a mux is needed, otherwise, 
       return the empty list *)
    If[ !needsMuxQ[ rhs, zeroReg ], 
      Return[ { newdecl, newequations } ] 
    ];

    If[ verb||dbg, Print["    ---- Muxing equation of ", var, "..."] ];
(* 
    If[ verb||dbg, Print["   is in ST form"] ];
*)

    If[ dbg, ashow[ getEquation[ var ] ] ];

    If[ verb||dbg, 
      Print[ "---- Spatial case: ", isSpatialCaseEquQ[ getEquation[ var ], 
        strictCase -> False ]]
    ];
    If[ verb||dbg, 
      Print[ "---- Temporal case: ", isTemporalCaseEquQ[ getEquation[ var ], 
      strictCase -> False ]]
    ];

    If[ (verb||dbg) && isTemporalCaseEquQ[ getEquation[ var ] ], 
	Print["This equation does not need a multiplexer..."] 
    ];

    (* Now, for each branch of the case, we create 
       a multiplexer. 
       rhs is assumed to have the form case, and a list
       of branches inside. 
    *)
    branches = rhs[[1]];

    For[restrList = {};j=1, 
      j<=Length[branches], 
      j=j+1,

      (* This is done for all restrictions in rhs *)
      restr = branches[[j]];

      If[ dbg, Print["---Branch: \n", 
        ashow[ restr, silent->True ] ] ];

      (* If the branch is not a case, then we simply
         keep it in the restriction list *)
      If[ 
        !MatchQ[restr, restrict[_,case[___]]| case[___] ]
      , 
        If[ dbg, Print["This branch is not a case." ] ];
        restrList = Append[restrList, restr]
      ,

        (* Notice : the case expression may or may not be
           preceded by a restriction. We keep track of this 
           in the variable casexpr *)
        casexpr = 
        If[ MatchQ[ restr, restrict[_, case[___] ] ], 
           restr[[2]], 
           restr 
        ]; 

        (* posbranch contains the position of the branch *)
        posbranch = Join[ poseq[[1]], {2,1,j}]; 

        If[verb, Print["    A multiplexer is needed..."]];
          (* the convexise is temporarily removed
             because of a bug in DomConvex
             ctldom = convexize[DomIntersection[
             getContextDomain[sys, posbranch], expDomain[sys, restr ] ]]; 
          *)

        (* The control domain is the domain of the restriction *)
        Check[
          tempdom1 = expDomain[sys, restr ],
          makeOneMuxControl::err1 = "error while calling expDomain";
          Throw[ Message[ makeOneMuxControl::err1] ]        
        ];

        Check[ 
          tempdom2 = 
            getContextDomain[ sys, posbranch ],
          makeOneMuxControl::err2 = "error while calling getContextDomain";
          Throw[ Message[ makeOneMuxControl::err2] ]      
        ];

        Check[
          ctldom = DomIntersection[ tempdom2, tempdom1 ],
          makeOneMuxControl::err3 = "error while calling DomIntersection";
          Throw[ Message[ makeOneMuxControl::err3] ]        
        ];

        If[dbg, Print["    Control domain : ", 
          ashow[ ctldom, silent->True]] ];

        (* The true domain is the domain of the first branch *)
        domTrue = 
          If[ !MatchQ[ restr, _restrict ],
            Part[restr,1,1,1],
            Part[restr,2,1,1,1]
          ]; 
        If[dbg, Print["    Dom True :\n", ashow[domTrue,silent->True]] ];

        (* The true domain is the domain of the second branch *)
        domFalse = 
          If[ !MatchQ[ restr, _restrict ],
            Part[restr,1,2,1],
            Part[restr,2,1,2,1]
          ]; 

        If[dbg, 
          Print["    Dom False :\n", ashow[domFalse,silent->True]] ];

        (* The declaration list is modified *)
        newdecl = Append[ newdecl, 
(*
                decl[ var<>"_ctl"<>ToString[j],boolean,ctldom ] 
*)
                decl[ var<>"Xctl"<>ToString[j],boolean,ctldom ] 
        ];

        (* A mux signal is build *)
        muxSignal =
          restrict[ctldom,
(*
            buildOneMuxedSignalDef[ sys, casexpr, var<>"_ctl"<>
*)
            buildOneMuxedSignalDef[ sys, casexpr, var<>"Xctl"<>
	    ToString[j] 
                  ]
          ];

        If[ dbg, 
          Print["  muxSignal : ", ashow[ muxSignal, silent->True ] ]
        ];

        (* A new restriction is added to the list *)
        restrList = 
          Append[ restrList, restrict[ ctldom, muxSignal ] ];

        (* And a mux controller is build *)
        Check[
          muxCtrl = 
            case[{
              restrict[ ctldom, 
                buildOneMuxCtrl[ casexpr ]
            ]} 
          ],
          Throw[ Null ]
        ];

        (* This new equation is added to the list of equations *)
        newequations = 
          Append[
            newequations,
(*
            equation[ var<>"_ctl"<>ToString[j], muxCtrl ] 
*)
            equation[ var<>"Xctl"<>ToString[j], muxCtrl ] 
        ];

      ]; (* End if *)

    ]; (* End for j *)
    
    (* Update the equation list *)
    newequations = Append[newequations, equation[var,case[restrList]]];

     (* Return *)
    { newdecl, newequations }
  ]
];
makeOneMuxControl[___] := Message[ makeOneMuxControl::params ];

(* first check if there are temporal cases other than binary; the list of
   restrictions is supposed to be a S-T hierarchy *)

Clear[allCasesBinaryQ]
allCasesBinaryQ[restrList:{_Alpha`restrict..}] :=
  (Cases[restrList, (c_Alpha`case /; (Length[c[[1]]] <= 2)),Infinity] ===
  Cases[restrList, c_Alpha`case,Infinity])

(* check if an expression contains is a full-formed space-time case *)

Clear[needsMuxQ];
needsMuxQ[c:_case,zeroReg_] :=
Module[{res,posSecondCase,caseBranches},

  (* Get the list of positions of cases at level 3 *)
  posSecondCase = Position[c, case, 3];

  (* If no case expressions, return false *)
  If[ posSecondCase==={}, Return[False] ];

  (* Zero Initialization need a signal control.
     This is conditioned by the zeroReg option. *)
  If[ zeroReg, Return[True] ];

  (* Zero Initialization do not need a signal control *)
  caseBranches = 
    Flatten[
      Cases[ c, case[b1_]->b1, 3]
  ];

  If[ Position[caseBranches,const[0]]=!={},
    (* Send a warning *)
    Print["Warning, no control signal was generated for expression :\n", 
          ashow[c, silent->True],
          "\nplease check the result"];
        res=False,
        res=True
  ];
res
];
needsMuxQ[_,_] := False;

(* 
   define mux control variable; takes only binary temporal cases; replaces the
   case expression in the order

   case
     D1 : True.(inds->);
     D2 : False.(inds->);
   esac

*)

Clear[buildMuxCtrl];
buildMuxCtrl[restrList:{_Alpha`restrict..},
	     ctrlVarName_String] :=
  With[{tempCasePosition =
	Position[restrList, _Alpha`case]},
       Alpha`equation[
	 ctrlVarName,
	 Alpha`case[
	   MapAt[buildOneMuxCtrl,
		 restrList,
		 tempCasePosition]]]]

Clear[buildOneMuxCtrl];
buildOneMuxCtrl[c:_case] :=
Catch[
Module[
  {dimension, indices, dependenceMatrix},

  dimension = Part[c, 1, 1, 1, 1];	     (* domain dimension *)
  indices = Part[c, 1, 1, 1, 2];	     (* domain index list *)
  dependenceMatrix = 
     matrix[1, 1 + Length[indices], indices,
       {Join[Table[0, {Length[indices]}], {1}]}];

  If[ !MatchQ[ c, case[{restrict[___],restrict[___]}] ], 
    makeAllMuxControl::argerr = 
      "this expression should be a binary case statement";
    Throw[ ashow[c]; Message[ makeAllMuxControl::argerr ] ]
  ];

  ReplacePart[
    ReplacePart[c,
      affine[const[True], dependenceMatrix],
      {1, 1, 2}
    ],
      affine[const[False], dependenceMatrix],
      {1, 2, 2}
  ]
]
];
makeAllMuxControl::params = "wrong params"; 
buildOneMuxCtrl[___] := Message[ makeAllMuxControl::params ];


(* reconstructs the spatial definition of the muxed signal; replaces the
   temporal cases (see "buildMuxCtrl") of the form

   case
     D1 : E1;
     d2 : E2
   esac

  ****BEFORE***with 
  ****BEFORE***if MuxCtrlVariable then E1 else E2;
 

***important change by Florent, on Patricia''s request:

with
 if MuxCtrlVariable then 
    case
      D1 : E1 ;
      D2 : true;  (or 0 if E1 is typed as number)
     esac
 else
    case
      D1 : true;  (or 0 if E1 is typed as number)
      D2 : E2
     esac

 *)
(**)

Clear[buildMuxedSignalDef];

buildMuxedSignalDef[sys_Alpha`system,
		    restrList:{_Alpha`restrict..},
		    ctrlVarName_String] :=
  With[{tempCasePosition = Position[restrList, _Alpha`case]},
       MapAt[buildOneMuxedSignalDef[sys, #, ctrlVarName]&,
	     restrList,
	     tempCasePosition]];


Clear[buildOneMuxedSignalDef];
buildOneMuxedSignalDef[sys_Alpha`system,
		       c_Alpha`case,
		       ctrlVarName_String] :=
  Module[{defTrue,defFalse,domTrue,domFalse,dimension,
	  indices,dependenceMatrix,defVoid},
	 defTrue = Part[c, 1, 1, 2];
	 defFalse = Part[c, 1, 2, 2];
	 domTrue = Part[c,1,1,1] (* Domain of the truebranche *);
	 domFalse = Part[c,1,2,1] ;
	 dimension = Part[c, 1, 1, 1, 1] (* domain dimension *);
	 indices = Part[c, 1, 1, 1, 2] (* domain index list *);
	 dependenceMatrix =
	   Alpha`matrix[1,
			1 + Length[indices],
			indices,
			{Join[Table[0, {Length[indices]}],
			      {1}]} ];
	 defVoid = Alpha`affine[ If[expType[sys, defTrue]===Alpha`boolean,
				    Alpha`const[False],
				    Alpha`const[0] ],
				 dependenceMatrix ];
	 Alpha`if[Alpha`var[ctrlVarName],
		  Alpha`case[
		    {Alpha`restrict[domTrue,
				    defTrue],
		     Alpha`restrict[domFalse,
				    defVoid]} ],
		  Alpha`case[
		    {Alpha`restrict[domTrue,
				    defVoid],
		     Alpha`restrict[domFalse,
				    defFalse]} ]	
		]
    ];


				   
	

Clear[makeMuxControl];
makeMuxControl[varName_String,
	       ctrlVarName_String,
	       timeIndexPos:{_Integer..},
	       spaceIndexPos:{_Integer..}] :=
  (Alpha`$program = Alpha`$result;
   Alpha`$result = makeMuxControl[Alpha`$result,
				  varName,
				  ctrlVarName,
				  timeIndexPos,
				  spaceIndexPos]);

makeMuxControl[sys:Alpha`system[n_, p_, i_, o_, locals_, equas_],
	       varName_String,
	       ctrlVarName_String,
	       timeIndexPos:{_Integer..},
	       spaceIndexPos:{_Integer..}] :=
  With[
    {equaPos = First[Position[equas, Alpha`equation[varName,_]]]},
    With[
      {restrList = Apply[Part, Join[{equas}, Join[equaPos, {2, 1}]]]},
      If[!MatchQ[restrList, {_Alpha`restrict..}],
	 (Print[InputForm[restrList]] ;
	  Print["\n*** Case-based definition expected.\n"];
	  Return[{}])] ;
      If[!allCasesBinaryQ[restrList],
	 (Print[VarName];
	  Print["Binary temporal cases expected"];
	  Return[{}])]; (*This should be here but does not work *)
      Alpha`system[n,p,i,o,		     (* unchanged ... *)
		   Append[locals,	     (* control var declaration *)
			  Alpha`decl[ctrlVarName,
				     Alpha`boolean,
				     Part[getDeclaration[sys, varName], 3]]],
		   Insert[
		     ReplacePart[
		       equas,
		       buildMuxedSignalDef[sys,restrList, ctrlVarName],
		       Join[equaPos, {2, 1}]], (* replace restr list *)
		     buildMuxCtrl[restrList, ctrlVarName],
		     equaPos+1]]]];



makeMuxControl[___]:=Message[makeMuxControl::args];

Clear[temporalCaseQ];

temporalCaseQ[caseExp:Alpha`case[restrictions_List],
               timeIndexPos:{_Integer..},
	      spaceIndexPos:{_Integer..}] :=
  temporalCaseQ[
    Alpha`$result,
    Alpha`case[restrictions],
    timeIndexPos,
    spaceIndexPos
  ];

temporalCaseQ[
  sys_Alpha`system,
  caseExp:Alpha`case[restrictions_List],
  timeIndexPos:{_Integer..},
  spaceIndexPos:{_Integer..}] :=

  With[{subdomList = Map[(canonicalProjection[expDomain[sys, #],
					      timeIndexPos])&, restrictions]},
       allDomEqualQ[subdomList]
  ];

temporalCaseQ[___]:=False;

Clear[spatialCaseQ];
(* Notice that a case expression with only one branch is 
   always a space case. Is this correct?  *)
spatialCaseQ[
  caseExp:case[restrictions_List],
  timeIndexPos:{___Integer},
  spaceIndexPos:{___Integer}] :=
spatialCaseQ[$result, case[restrictions], timeIndexPos, spaceIndexPos];

spatialCaseQ[
  sys:_system,
  caseExp: case[restrictions_List],
  timeIndexPos: {___Integer},
  spaceIndexPos: {___Integer}] :=
With[{subdomList = 
  Map[(canonicalProjection[expDomain[sys, #], timeIndexPos])&, restrictions]},
       allDomDisjointQ[subdomList]
];

spatialCaseQ[___]:=False;

(* build a "controlled" temporal case given a condition variable and a default
   expression (usually a constant, of the same type as the expressions in the
   case) *)

Clear[buildControledCase];
buildControledCase[Alpha`case[{r1_Alpha`restriction[domD1_, exprE1_],
			       r2_Alpha`restriction[domD2_, exprE2_]}],
		   condVariable_String,
		   defaultExpression_] :=
  Alpha`case[
    {Alpha`restriction[domD1,
		       Alpha`if[Alpha`var[condVariable],
				exprE1,
				defaultExpression]],
     Alpha`restriction[domD2,
		       Alpha`if[Alpha`unop[Alpha`not,
					   Alpha`var[condVariable]],
				exprE2,
				defaultExpression]]}];


(* build the definition of the controlling variable for a temporal case*)

Clear[buildControlVarEquation];
buildControlVarEquation[Alpha`case[{r1_Alpha`restriction[domD1_, exprE1_],
			       r2_Alpha`restriction[domD2_, exprE2_]}],
			condVariable_String] :=
  With[{constFunction = makeConstantFunction[Part[domD1, 1]]},
       Alpha`equation[condVariable,
		      Alpha`case[
			{Alpha`restriction[domD1,
					   Alpha`affine[Alpha`const[True],
							constFunction]],
			 Alpha`restriction[domD2,
					   Alpha`affine[Alpha`const[False],
							constFunction]]}]]];


(* build the declaration of the condition variable *)

Clear[buildControlVarDeclaration];
buildControlVarDeclaration[dom_Alpha`domain, varName_String] :=
  Alpha`decl[varName, Alpha`bool, dom];


(* Generalized case transformation suite *)

Clear[convertCaseToBinaryTree] (* to do *)

(* Check for nonempty domains *)
Clear[nonEmptyQ];
nonEmptyQ[d_Alpha`domain] := Not[DomEmptyQ[d]]
nonEmptyQ[_] := False;

(* True if an equation is a control equation *)
Clear[ isControlEquQ ];
isControlEquQ[e_Alpha`equation]:=
Catch[
  Module[ { normEq, casePos },

    (* Normalize *)
    normEq = normalize0[e];

    casePos = Position[normEq,Alpha`case];

    If[ Length[casePos]<1,
      Throw[False],
      curCasePos = Last[casePos];
      curCase = getPart[normEq,Drop[curCasePos,-1]];
      MatchQ[curCase,
        Alpha`case[
          {Alpha`restrict[_Alpha`domain,
             Alpha`affine[Alpha`const[True], _Alpha`matrix]],
           Alpha`restrict[_Alpha`domain,
             Alpha`affine[Alpha`const[False], _Alpha`matrix]] 
          } 
        ]
      ],
      Null
    ]
  ]
];
		    
isControlEquQ[e_Alpha`equation2]:=
  MatchQ[e[[2]],
	 Alpha`case[
	   {Alpha`restrict[
	     _Alpha`domain,
	     Alpha`case[
	       {Alpha`restrict[_Alpha`domain,
			       Alpha`affine[Alpha`const[True],
					    _Alpha`matrix]],
		Alpha`restrict[_Alpha`domain,
			       Alpha`affine[Alpha`const[False],
					    _Alpha`matrix]] } ]
	   ], (* a possible second branch used only in 
		 pipeControl procedure *) ___ } ] ] 

isControlEquQ[___]:=False

Clear[ controlVars ];
controlVars[] := controlVars[Alpha`$result];

controlVars[sys_Alpha`system] := 
  Map[ First, Select[sys[[6]], isControlEquQ ] ];
controlVars[___]:=Message[controlVars::params];

End[];
EndPackage[];

