\chapter{Static analysis of {\alfa} programs\label{static}\label{chapanalyze}}

\section{Introduction}


This chapter describes the use of the static analysis tool
\texttt{analyze[]}.\index{analyze[]}  
It is divided in two parts: the first part deals with the
static analysis of a single system, and the second describes the
analysis of a structured program consisting of several systems. Any
beginner in {\alfa} should read the first part, while the
second part is left to more experienced users.



\subsection{What is static analysis?\index{static analysis}}

It is impossible to ensure that an {\alfa} system computes the
expected result (to start with, the termination of such computation is
well known to be indecidable). However there are a few necessary
conditions for a system to be valid which may be verified
\emph{statically}, that is

\begin{itemize}

\item independently of any set of input values that may be fed to the
system, and
\item in a manner that is valid for any of these set of values.

\end{itemize}


\subsection{What does the static analyzer do?}

The {\alfa} static analyzer basically verifies the following rule:

\emph{For each point of the domain of a variable, there is
one and only one computation defining the value of the variable at
this point.}

The static analyzer checks that this rule is ensured and outputs error
messages giving the points where a variable is over- or under-defined.



\subsection{When should the static analyzer be used?}

This tool is very useful while writing and debugging {\alfa} code, and
should be invoked systematically. Besides, 

{\large
\begin{center}
\emph{{\alfa} program transformations are only guaranteed to work}

\emph{on programs that pass the static analysis without error messages.}

\end{center}
}

This is in particularly true of the {\alfa} to C translator \index{writeC}
\texttt{writeC[]}: the C code generated by this command is likely to
cause run-time errors if the initial {\alfa} program doesn't pass the
static analysis. Therefore the static analyzer should be called before any
simulation of the {\alfa} program.


\subsection{An example\index{gaussian elimination}}

We will use in this chapter the following two-system example program
which transforms a matrix into triangular form as first step of a
Gaussian elimination\footnote{This program is neither optimal nor
complete, it was written for the purpose of demonstrating the
\textsc{analyze[]} function. Writing a complete Gaussian elimination
is left as an exercise to the reader.}.

The first system takes a square matrix and zeroes all the elements
below the \texttt{K}-th diagonal of this matrix (one slice of
Fig.\ref{gauss-slices}):

\begin{verbatim}
 system ZeroColumn: {N,K| 1<=K<N} (A: {i,j| 1<=i,j<=N} of real)
                          returns (Ar: {i,j| 1<=i,j<=N} of real);
 let
   Ar[i,j] = case
             {| i<=K}      : A[i,j];
             {| i>K; j<=K} : 0[];
             {| i>K; j>K}  : A[i,j] - A[K,j]*A[i,K]/A[K,K];
             esac;
 tel; 
\end{verbatim} 

The second system uses N instances of the first to compute the
triangular matrix (see Fig.ref{gauss-slices}):

\begin{verbatim}
 system Gauss: {N | N>1} (A: {i,j | 1<=i,j<=N} of real)
                 returns (T: {i,j | 1<=i,j<=N} of real);
 var Ak : {i,j,k| 1<=i,j<=N; 1<=k<=N} of real;
     Ak1: {i,j,k| 1<=i,j<=N; 1<=k<N} of real;
 let
   use {k| 1<=k<N} ZeroColumn[N,k] (Ak) returns (Ak1);
   Ak[i,j,k] = case
               {| k=1} : A[i,j];
               {| k>1} : Ak1[i,j,k-1];
               esac;
   T[i,j] = Ak[i,j,N];
 tel;
\end{verbatim} 

\begin{figure}
\centerline{
	\includegraphics[width=8cm]{figures/gauss}
        }
\label{gauss-slices}
\caption{Triangularization in two systems}
\end{figure}



What kind of information does the static analyzer give? Suppose a typo
has replaced an \texttt{j} index with a \texttt{i} index, leading to
the following \texttt{ZeroColumn} program:

\begin{verbatim}
 system ZeroColumn: {N,K| 1<=K<N} (A: {i,j| 1<=i,j<=N} of real)
                          returns (Ar: {i,j| 1<=i,j<=N} of real);
 let
   Ar[i,j] = case
             {| i<=K}      : A[i,j];
             {| i>K; i<=K} : 0[];     -- The typo is hidden here
             {| i>K; j>K}  : A[i,j] - A[K,j]*A[i,K]/A[K,K];
             esac;
 tel;
\end{verbatim} 

This error can't be detected by a parser program -- this program is
syntactically correct. However, invoking the static analysis will
yield the following messages:\index{analyze[]}

\begin{verbatim}
In[5]:= analyze[];
 
WARNING: This expression has an empty domain :
{i,j | i=0; j=0; N=0; K=0; 1=0} : 0.(i,j->)
 
ERROR: Variable Ar not defined over the domain :
{i,j | K+1<=i<=N; 1<=j<=K}
 
*** Analysis failed ***
\end{verbatim}

A warning and an error tell us that there is an error in the equation
defining \texttt{Ar}. Several \emph{error domains} may help us pinpoint
precisely where the error is. The first warning message is enough
to spot that the error is in the \texttt{case} subexpression
containing the \texttt{0[]}. The \texttt{1=0} equation in the domain
indicates that this domain is empty.\index{empty domain}

As this example shows, it may take a certain amount of experience
to fully understand the error messages: the error domains
are not always in the most readable form. However the indications
given usually allow to spot the problem precisely: in our example the
combination of both previous messages points exactly to the cause of
the error.


The remainder of this paper describes the static analysis tool in more
details.



\section{Static analysis of an {\alfa} system}
\label{static-analysis}


\subsection{The domain of an expression\label{expr_check}}

\index{expression domain}\index{domain of an expression} In {\alfa}
every variable is declared with a polyhedral domain defining the set
where it is expected to contain a value.\index{declaration
domain}\index{domain of a variable}

When an expression is built using such variables, this expression
inherits the domain of these variables: for example if \texttt{A} and
\texttt{B} are two expressions defined over some square domain
\texttt{\{i,j|0<i,j<10\}}, then their
sum \texttt{A+B} is defined everywhere both \texttt{A} and \texttt{B}
are defined, that is on the same square domain.

Now if the domains of \texttt{A} and \texttt{B} are different, then
the sum is still defined everywhere both \texttt{A} and \texttt{B} are
defined, that is on the intersection of the domains of \texttt{A} and
\texttt{B}.

It is possible to carry these ideas further, and thus to define the
domain of any {\alfa} expression, knowing the domains of the
subexpressions (see the discussion of section~\ref{arrayform},
page~\pageref{arrayform}). The rules to apply, given below, are actually part of
the definition of the semantics\index{semantics of {\alfa}} of the
language. They rely only on operators preserving the set of {\alfa}
domains and thus may be computed automatically: this is what the
static analyzer does.


 \begin{center}
  \begin{tabular}{rc}
   {Constants} & \fbox{$Dom(c) = \mathbf{Z}^0$} \vspace{1ex}\\ 
   {Variables} & \fbox{$Dom(V) \textrm{ is declared in the header}$}\vspace{1ex}\\ 
   {Unary operators} & \fbox{$Dom(-e) = Dom(e)$}\vspace{1ex}\\ 
   {Binary operators} & \fbox{$Dom(e_1+e_2) = Dom(e_1) \cap Dom(e_2)$}\\
   & {\small The sum of two variables is defined where both variables are defined}\vspace{1ex}\\ 
   {Ternary operators} & \fbox{$Dom(\texttt{if}\ e_1\ \texttt{then}\ e_2\ \texttt{else}\ e_3) = 
            \bigcap_{i=1}^3 Dom(e_i)$}\\
   & {\small The \texttt{if}\ \texttt{then}\ \texttt{else}\ is considered as a ternary operator}\\
   & {\small and is defined where the condition and both alternatives are defined}\vspace{1ex}\\ 
   {Restriction} & \fbox{$Dom(D : e) = D\cap Dom(e)$}\\
   {\small $D$ is a domain} 
   & {\small This operator restricts an expression to D}
   \vspace{1ex}\\
   {Affine dependency} & \fbox{$Dom(e[f]) = f^{-1}(Dom(e))$}\\
   {\small $f$ is an affine function}
    & {\small The value of $e[f]$ at point \textbf{z} is the value of $e$}\\
   {\small of the indices of the LHS}
    & {\small at point $f(\mathbf{z})$, hence the domain of $e[f]$}
  \vspace{1ex}\\
   {\texttt{case} operator} 
   & \fbox{$Dom(\texttt{case} e_1;..;e_n;\texttt{esac}) = \bigcup_{i=1}^n Dom(e_i)$}\\
   & {\small The \texttt{case} operator allows the piecewise definition of an expression}\\
   & {\small by several subexpressions $e_i$ with disjoint domains.}
  \end{tabular}
 \end{center}

The function \texttt{expDomain[]} \index{expDomain[]} may be used to
compute the domain of any {\alfa} expression, following these rules.

Now during the computation of the domain of an expression, the
\texttt{case} operator \index{case} introduces the possibility of
having more than one subexpression define the value of the same point
of the domain.  Therefore the analysis tool has to check that the
intersections of the domains of the case subexpressions are empty. It
computes this intersection, and if it not empty it issues an error
message as in the following example:
\index{overlap of case statements}\index{analysis of the case}\index{case validity}

\textbf{Example:} in the equation defining \texttt{Ar}, if the
second line of the \texttt{case} was wrongly written:
\begin{verbatim}
      {| i>=K; j<=K}: 0[];
\end{verbatim}
The analysis tool will output the following message:
\begin{verbatim}
 ERROR: in case statement: ...,
        domains of subexpressions overlap on:
        {i,j | i=K; 1<=j<=K}
\end{verbatim}


There are other useful informations which the static analyzer
provides. For example it is useful to detect an empty expression
i.e. an expression with an empty domain: such an expression is 
in the best case pointless (in a case statement), and may be a source of
errors. \index{expression has an empty domain}\index{empty domain}
To avoid cascaded error messages, only the
deepest empty subexpression is reported to the user.

\textbf{Example:}
 Still in the same equation, a mistake in the first \texttt{case} subexpression:
\begin{verbatim}
      {| i<=0}     : A[i,j];
\end{verbatim}
will cause the following messages:
\begin{verbatim}
 WARNING: This expression has an empty domain: 
          {| i<=0} : A[i,j]
 ERROR:   Variable Ar not defined over the domain: 
          {i,j| 1<=i<=K; 1<=j<=N}
\end{verbatim}



\subsection{Equation analysis\label{equ_check}}

\index{equation analysis}\index{analysis of an equation} Now we
describe how the static analyzer works: it considers each equation
$V[i,j\ldots] = e$, where $e$ is an {\alfa} expression.  To ensure
that there is at least one computation defining the value of $V$ for
each point $(i,j,\ldots)$ of its domain, the analysis tool computes
$D' = Dom({V}) \setminus Dom({e})$, where $\setminus$ denotes the set
difference, $Dom(V)$ is the domain of the variable $V$ (declared in
the header of the system), and $Dom(e)$ is the domain of the
expression as defined above.\index{declaration domain}\index{domain of
a variable}
 
If $D'$ is non empty, an error is issued, stating that $V$ is not
defined over $D'$. This error domain will be useful to the user to
spot the problem. \index{variable not defined}

\textbf{Example:} In the equation of the system \texttt{ZeroColumn} 
 defining \texttt{Ar}, 
suppose the first line of the \texttt{case} statement was mistyped:
\begin{verbatim}
      {| i<K}     : A[i,j];    -- instead of {| i<=K} ...
\end{verbatim} 
(notice the \verb~<K~ instead of \verb~<=K~). The analysis tool will output
 the following message:
\begin{verbatim}
 ERROR: Variable Ar not defined over the domain:
        {i,j| i=K; 1<=j<=N}
\end{verbatim} 




\subsection{Parameter related analysis\label{param-check}}

\index{parameter analysis}\index{analysis of a parameterized system}
If the system considered is parameterized, the static analysis process
may be usefully refined by taking the parameters into
account. Consider again the \texttt{Gauss} system:

\begin{verbatim}
 system Gauss: {N | N>1} (A: {i,j | 1<=i,j<=N} of real)
                 returns (T: {i,j | 1<=i,j<=N} of real);
 var Ak : {i,j,k| 1<=i,j<=N; 1<=k<=N} of real;
     Ak1: {i,j,k| 1<=i,j<=N; 1<=k<N} of real;
 let
   use {k| 1<=k<N} ZeroColumn[N,k] (Ak) returns (Ak1);
   Ak[i,j,k] = case
               {| k=1} : A[i,j];
               {| k>1} : Ak1[i,j,k-1];
               esac;
   T[i,j] = Ak[i,j,N];
 tel;
\end{verbatim} 


Suppose there was no restriction on the parameter \texttt{N} of the
system \texttt{Gauss}. Its header would be: \mbox{\verb~ system Gauss:
\{N |\} ~}.  Now obviously for negative values of \texttt{N}, all the
variables of this system have an empty domain, \index{expression has
an empty domain}\index{empty domain} which should be pointed to the
user as a possible source of errors.  The static analyzer performs
such parameter-related checks.

\textbf{Example:}
 We may restrict the parameter \texttt{N} of the system \texttt{Gauss} to
 be positive:
\begin{verbatim}
 system Gauss: {N | N>0}  
\end{verbatim}
One may check that the system is still valid, even for \texttt{N=0}.
 However the analysis will issue the following message:
\begin{verbatim}
 WARNING: for parameters {N| N=1}, the expression Ak1 has an empty domain
\end{verbatim}


It is good programming practice to ensure that the system is valid for
all the values of its parameter domain. It becomes mandatory if the
program is composed of several systems, as shown in the following
section.




\section{Analysis of structured programs}
\index{analysis of structured programs}

\subsection{Analysis of \texttt{use}\ statements\label{useanalysis}}
\index{analysis of the use}\index{use statement analysis}\index{validity of the use}

The analysis of a \texttt{use} statement is deduced from its
\index{substitution semantics}\index{semantics of the use}
\emph{substitution semantics}: in short, a program containing a
\texttt{use}\ statement is (by definition of the use) equivalent to
one where this statement has been replaced with the body of the
subsystem (properly modified to take into account the extra dimensions
and the affine parameter assignment) and additional equations to
perform the I/O passing: input equations relate the actual inputs and
the formal ones~:
\begin{verbatim}
      SubSystemInputVariable = ActualInputExpression ;
\end{verbatim} 
and output equations relate the actual outputs and the formal ones~:
\begin{verbatim}
        ActualOutputVariable = SubSystemOutputVariable ;
\end{verbatim} 


\paragraph{Global checks}
The first validity conditions are that the subsystem has been declared
somewhere in the program, that the correct number of actual
inputs/outputs are given, and that their respective dimensions match
the formal ones.  The tool also checks, using the same techniques as
previously, that the extension domain is non-empty for all the values
of the parameters.

\index{parameter assignment}\index{assignment of the
parameters}\index{parameters}\index{validity of the parameter
assignment} 
Then we consider the values given to the parameters of
the subsystem by the caller. The parameters of the subsystem are
an affine function of the caller parameter and,
possibly, the extension indices.  The analyzer checks that, for all
the possible values of the caller parameters, and for all the points
in the extension domain, the values assigned to the subsystem
parameters fall within the range permitted, i.e. within the parameter
domain of the subsystem.  Otherwise an error message is issued,
showing a domain which is the set of points where parameters are given
but not expected.


\textbf{Example:}
In the \texttt{Gauss} system, the following \texttt{use}\ statement:
\begin{verbatim}
    use {k| 0<=k<=N} ZeroColumn[N,k] (Ak) returns (Ak1);
\end{verbatim}
will cause the following message:
\begin{verbatim}
 ERROR : in statement ``use ... ZeroColumn...'',
         parameter values in {N,K| K=0, N>=1} not allowed.
\end{verbatim}
 
Obviously, the more restricted the parameter domain of the subsystem,
the more acurate the checks performed here.


\paragraph{Input/Output checks}

\index{subsystem input/output}
The substitution semantics implies that the verifications to be
performed on the I/Os of a subsystem \texttt{use}\ may be deduced from
those of the equations described in \ref{equ_check}. Error messages
are given accordingly.



\subsection{Global analysis of a library of systems}

\index{analysis of a structured program}
The validity of a \texttt{use}\ statement is then implied by the
validity of the subsystem on its parameter domain, the condition that
all the parameter values assigned by a \texttt{use} are allowed, and
the validity of the virtual I/O passing equations.

We may thus describe the general down-top verification method for a
complete program. Such a program is an acyclic graph of {\alfa}
systems using each other (system \texttt{use} can not be mutually
recursive). Systems without a \texttt{use}\ statement in their
equations are called {\em leaves}. A system using a subsystem is
called a {\em parent} of this subsystem.
\begin{itemize}
\item First, the leaves are analyzed, and their parameter domain is
restricted as much as possible. No warning message should remain.  For
example, for the system \texttt{ZeroColumn}, we have to restrict
\texttt{K} and \texttt{N} at least to the domain given in the
correct version of this sytem (it is possible to constraint the
parameters more than what the analysis suggests. For example we could
put a bound on \texttt{N} depending on the application aimed at).

\item Then the parents of the leaves are analyzed. If they are written
to use a leaf with illegal values of its parameters, the tool
will spot it and the programmer will be invited either to correct the
error, or to restrict more the caller parameters. Meanwhile, the other
equations of the caller are also analyzed, with the same effect.

\item This process is repeated on the parents of the parents, and so
on until the whole program passes the static analysis.
\end{itemize}

Note that one of the options to \texttt{analyze[]} decides whether the
analysis is performed recursively on all the subsystems of the system
currently being analyzed, or only to this system.
