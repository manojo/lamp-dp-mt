%{
 /*  file: $MMALPHA/sources/Write_C/yacc.y
   AUTHOR : Doran Wilde
   CONTACT : http://www.irisa.fr/api/ALPHA
   COPYRIGHT  (C) INRIA
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   (see file : $MMALPHA/LICENSING).

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library(see file : $MMALPHA/LICENSING);
   if not, write to the Free Software Foundation, Inc., 59 Temple
   Place - Suite 330, Boston, MA  02111-1307, USA. */

#define GREETING "\
/* C-Code generated by Alpha Code Generator version 1.2 */\n\n"

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
/* Previously, the 3 following includes were in Pretty */
#include "../Write_Alpha/item.h"
#include "../Write_Alpha/itemprocs.h"
#include "../Write_Alpha/writeitem.h"

#include <polylib/polylib.h>
#include "../Code_Gen/node.h"
#include "../Code_Gen/nodeprocs.h"
#include "../Code_Gen/gen.h"

#define FREE  1
#define FIXED 2         /* equation i = 2k + +3j +1 */
#define SUBST 3         /* sub i with 2k - 5 */
#define CONST 4         /* sub i with 2 */
/* note: global parameters are always fixed indices */

int	lineNb;		/* Current input line number */
item	*alpha;		/* The alpha tree */
node	*alpha_node;	/* The (partial) alpha node tree */
int	G_dim = 0;	/* Dimension of parameter space */

/* globals */
static  node *ID_List_Save=(node *)0, *Eqn_Decl=(node *)0, *Var_Decl=(node *)0,
             *Eqn_ID=(node *)0, *Olist=(node *)0, *Ilist=(node *)0;
static int case_flag = 0, olist_flag = 0, ilist_flag = 0,
          *G_val = (int *)0;
static int V_Save = 0;  /* the size of the current vector */
static int I_Save = 0;  /* the position of the next element in the vector */
static context_info *Context = (context_info *) 0;      /* current context */

/* flags for compile switches */
static int flag_quietProgram = 0;
static int flag_forSignal = 0; /* 1->the result must be produced for signal */
static int flag_loopNestForInputVariables = 1;

extern char    begcom[], endcom[];  /* comments */

/* comments around the debug statements in the C program */
static char begdbg[]="/* ",enddbg[]=" */";

/*--------------------------------------------------------------------*/
/* create_body ()                                                     */
/*	creates the function that computes local and output variables */
/*      such as the following example:                                */
/*                                                        ------------*/
/*  double compute_X(i,j,k)                               */
/*  int i,j,k;                                            */
/*  {                                                     */
/*    realvar *tmp;                                       */
/*    printf("Computing: X[%d,%d,%d]\n" ,i,j,k);          */
/*    tmp = &(X(i,j,k));                                  */
/*    if (!tmp->computed) {                               */
/*            tmp->value = <formula to compute X(i,j,k)>; */
/*       tmp->computed = 1;}                              */
/*    return tmp->value;                                  */
/*  }                                                     */
/*--------------------------------------------------------*/
static item *create_body(type, t1,t2,t3,id,idlist,unique,dim,infinite)
item *type,		/* intvar, realvar, or boolvar */
     *t1,		/* %d,%d,...  for indices, empty text for scalar */
     *t2,		/* */
     *t3,		/* int or double -- return type */
     *id,		/* Name of variable */
     *idlist,		/* Indices of variable */
     *unique;		/* Body of function -- code to compute value */
int  dim,		/* dim is 0 for scalars, the dim for arrays */
     infinite;		/* True if domain of variable is infinite */

{ if (dim)			/* array */
  { if (!infinite)			/* finite domain */
    { if (idlist->the.hsep.item_list)		/* finite array */
      {
        return Vsep3(0, "",
                  Hsep5(0, "",
                     Text("static "),
                     Copy(t3),
                     Text("compute_"),
                     Copy(id),
                     Henc(0,
                        Text("("),
                        Text(")"),
                        Copy(idlist)
                     )
                  ),
                  Hsep3(0, "",
                     Text("int "),
                     Copy(idlist),
                     Text(";")
                  ),
                  Venc(0, Text("{"), Text("}"),
                     Vlis5(0,"",
                        Hsep3(0, "",
                           Text("  "),
                           Copy(type),
                           Text("*tmp;")
                        ),
                        Henc(0, Text(begdbg),  Text(enddbg),
                           Hsep4(0, "",
                              Text("printf(\"Computing: "),
                              Copy(id),
                              Copy(t1),
                              Henc(0, Text("\\n\" ,"), Text(");"),
                                 Copy(idlist)
                              )
                           )
                        ),
                        Henc(0, Text("  tmp = &("), Text(");"),
                           Hsep2(0, "",
                              Copy(id),
                              Henc(0, Text("("), Text(")"),
			         Copy(idlist)
                              )
		           )
                        ),
                        Henc(5, Text("  if (!tmp->computed) {"), Text("}"),
                           Vlis2(0, "",
                              unique,
                              Text("tmp->computed = 1;")
                           )
                        ),
                        Text("  return tmp->value;")
                     )
                  )
               );
        }
      else						/* scalar ??? */
        return Vsep2(0, "",
                  Hsep5(0,"",
                     Text("static "),
                     Copy(t3),
                     Text("compute_"),
                     Copy(id),
                     Henc(0, Text("("), Text(")"),
                        Copy(idlist)
                     )
                  ),
                  Venc(0, Text("{"), Text("}"),
                     Vlis5(0, "",
                        Hsep3(0, "",
                           Text("  "),
                           Copy(type),
                           Text("*tmp;")
                        ),
                        Henc(0, Text(begdbg),  Text(enddbg),
                           Hsep4(0, "",
                              Text("printf(\"Computing ??: "),
                              Copy(id),
                              Copy(t1),
                              Henc(0, Text("\\n\""), Text(");"),
                                 Copy(idlist)
                              )
                           )
                        ),
                        Henc(0, Text("  tmp = &("), Text(");"),
                           Copy(id)
		        ),
                        Henc(5, Text("  if (!tmp->computed) {"), Text("}"),
                           Vlis2(0, "",
                              unique,
                              Text("tmp->computed = 1;")
                           )
                        ),
                        Text("  return tmp->value;")
                     )
                  )
               );
    }
    else			/* infinite array */
      return Vsep3(0, "",
                Hsep5(0,"",
                   Text("static "),
                   Copy(t3),
                   Text("compute_"),
                   Copy(id),
                   Henc(0, Text("("), Text(")"),
                      Copy(idlist)
                   )
                ),
                Hsep3(0,"",
                   Text("int "),
                   Copy(idlist),
                   Text(";")
                ),
                Venc(0, Text("{"), Text("}"),
                   Vlis4(0, "",
                      Hsep3(0, "",
                         Text("  "),
                         Copy(t3),
                         Text("tmp;")
                      ),
                      Henc(0, Text(begdbg),  Text(enddbg),
                         Hsep4(0, "",
                            Text("printf(\"Computing: "),
                            Copy(id),
                            Copy(t1),
                            Henc(0, Text("\\n\" ,"), Text(");"),
                               Copy(idlist)
                            )
                         )
                      ),
                      unique,
                      Text("  return tmp;")
                   )
                )
             );

  }
  else							/* scalar */
    return Vsep2(0, "",
              Hsep5(0,"",
                 Text("static "),
                 Copy(t3),
                 Text("compute_"),
                 Copy(id),
                 Henc(0, Text("("), Text(")"),
                    Copy(idlist)
                 )
              ),
              Venc(0, Text("{"), Text("}"),
                 Vlis5(0, "",
                    Hsep3(0,"",
                       Text("  "),
                       Copy(type),
                       Text("*tmp;")
                    ),
                    Henc(0, Text(begdbg),  Text(enddbg),
                       Hsep4(0, "",
                          Text("printf(\"Computing: "),
                          Copy(id),
                          Copy(t1),
                          Henc(0, Text("\\n\""), Text(");"),
                             Copy(idlist)
                          )
                       )
                    ),
                    Henc(0, Text("  tmp = &("), Text(");"),
                       Hsep2(0, "", Copy(id), Text("()"))
                    ),
                    Henc(5, Text("  if (!tmp->computed) {"), Text("}"),
                       Vlis2(0,"",
                          unique,
                          Text("tmp->computed = 1;")
                       )
                    ),
                    Text("  return tmp->value;")
                 )
              )
           );
}

/* creates input read functions and output and local predeclarations */
static item *convert_decl2(decls, status)
node *decls;
int status;
{ node *current;
  item *id, *t1, *t2, *t3, *idlist, *type, *unique=(item *)0, *tmp = (item *)0,
  *out = (item *)0;
  int flag = 0, i, dim, infinite;

  for (current=decls->the.list.first; current; current=current->next)
  { /* dim is 0 for scalars, the dim for arrays */
    dim = current->the.decl.domain->the.dom.dim - G_dim;
    /* create items to be used as building blocks */
    id = Text("");
    sprint_name(id->the.text.string,current->the.decl.id);

    t1 = Henc(0, Text("["), Text("]"), dim ? Text("%d") : Text(""));
    for (i=1; i<dim; i++)
      strcat(t1->the.henc.body->the.text.string,",%d");

    if (current->the.decl.type == realtype)
    { type = Text("realvar ");
      t2 = Text("atof");
      t3 = Text("double ");
    }
    else
    { if (current->the.decl.type == booltype) {type = Text("boolvar ");}
      else type = Text("intvar ");
      t2 = Text("atoi");
      t3 = Text("int ");
    }
    idlist = Hsep1(0,",",
                id_list_n(current->the.decl.domain->the.dom.index,G_dim)
             );

    /* test for an infinite domain, requiring different processing */
    if (current->the.decl.w) infinite=0; else infinite=1;

    /* build a declaration item */
    if (status)				/* return input declarations */
    { if (dim==0)                           /* scalar input */
      { if(flag_forSignal)
        { unique = Hsep4(0, "", Text("tmp->value = *"),
                       Copy(id), Text("_IO"), Text(";"));
        }
        else if (flag_quietProgram==1)
        { unique = Vsep2(0, "",
                    Text("gets(__s_);"),
                    Hsep3(0, "",
                       Text("tmp->value = "),
                       Copy(t2),
                       Text("(__s_);")
                    )
                 );
        }
        else
        { unique = Vsep3(0, "",
                    Hsep3(0, "",
                       Text("\n     printf(\"Input "),
                       Copy(id),
                       Henc(0, Text(" =\" "), Text(");"),
                          Text("")
                       )
                    ),
                    Text("gets(__s_);"),
                    Hsep3(0, "",
                       Text("tmp->value = "),
                       Copy(t2),
                       Text("(__s_);")
                    )
                 );
        }
      }
      else                                      /* array input */
      { if (!infinite)                          /* finite array input */
        { if(flag_forSignal)
          { unique = Hsep7(0, "", Text("tmp->value = ("),
                           Copy(t3),
                           Text(")(*"),
                           Copy(id),
                           Text("_IO)"),
                           Text("arrayAcces(current, G_dim)"), /* tmp soln */
                           Text(";"));
          }
          else if (flag_quietProgram==1)
          { unique = Vsep2(0, "",
                      Text("gets(__s_);"),
                      Hsep3(0,"",
                         Text("tmp->value = "),
                         Copy(t2),
                         Text("(__s_);")
                      )
                   );
          }
          else
          { unique = Vsep3(0, "",
                      Hsep4(0, "",
                         Text("\n     printf(\"Input "),
                         Copy(id),
                         Copy(t1),
                         Henc(0, Text(" =\" ,"), Text(");"),
                            Copy(idlist)
                         )
                      ),
                      Text("gets(__s_);"),
                      Hsep3(0,"",
                         Text("tmp->value = "),
                         Copy(t2),
                         Text("(__s_);")
                      )
                   );
          }
        }
        else                                    /* infinite array input */
        { if (flag_quietProgram==1)
          { unique = Vsep2(0, "",
                      Text("  gets(__s_);"),
                      Hsep3(0, "",
                         Text("  tmp = "),
                         Copy(t2),
                         Text("(__s_);")
                      )
                   );
          }
          else
          { unique = Vsep3(0, "",
                      Hsep4(0, "",
                         Text("  printf(\"Input "),
                         Copy(id),
                         Copy(t1),
                         Henc(0, Text(" =\" ,"), Text(");"),
                            Copy(idlist)
                         )
                      ),
                      Text("  gets(__s_);"),
                      Hsep3(0, "",
                         Text("  tmp = "),
                         Copy(t2),
                         Text("(__s_);")
                      )
                   );
          }
        }
      }
      tmp = create_body(type,t1,t2,t3,id,idlist,unique,dim,infinite);
    }
    else if (!status) /* return as predeclarations ie output and local decls */
    { tmp =    Hsep5(0, "",
                  Text("static "),
                  Copy(t3),
                  Text("compute_"),
                  Copy(id),
                  Text("();")
               );
    }
    /* add to out list */
    if (out && !flag) {new_list2(out,tmp); flag = 1;}
    else if (out && flag) add_to_ilist(out,tmp);
    else out = tmp;
  }
  return out;
}

%}
%token KW_system
%token KW_decl
%token KW_scalar
%token KW_integer
%token KW_boolean
%token KW_real
%token KW_equation
%token KW_case
%token KW_restrict
%token KW_var
%token KW_affine
%token KW_const
%token KW_binop
%token KW_unop
%token KW_if
%token KW_add
%token KW_sub
%token KW_mul
%token KW_div
%token KW_idiv
%token KW_mod
%token KW_eq
%token KW_le
%token KW_lt
%token KW_gt
%token KW_ge
%token KW_ne
%token KW_or
%token KW_and
%token KW_neg
%token KW_sqrt
%token KW_not
%token KW_domain
%token KW_pol
%token KW_matrix
%token KW_notype
%token KW_xor
%token KW_max
%token KW_min
%token KW_reduce
%token KW_depend
%token KW_dtable
%token KW_let
%token KW_loop
%token KW_use
%token KW_call
%token KW_abs
%token KW_true
%token KW_false
%token KW_pos_infinity
%token KW_neg_infinity

/*-----------------------------------------------------------------*/
/* I. General Specifications                                       */
/*-----------------------------------------------------------------*/
%token NUMBER
%token REAL
%token ID

%union	{ node *n; datatype t; item *i; int b; }
%type <n> Decl_List Decl 
%type <i> System_List System_Head System Let_Equations
%type <i> Equation_List Equation Exp_List Exp ID_item Constant 
%type <n> Pol_List Pol Matrix
%type <n> Number_List_List Number_List ID_List Domain 
%type <n> REAL ID
%type <t> Data_Type 
%type <i> Input_Decl Output_Decl Local_Decl Parameter
%type <b> Push_Clear_Case NUMBER

%start Top

%%
ID_item : ID
	{ $$ = Text("");
	  sprint_name($$->the.text.string,$1);
          free_node($1);
        }
/*-----------------------------------------------------------------*/
/* II. Function Specifications                                     */
/*-----------------------------------------------------------------*/
Top:   '{' System_List '}' 
	  { alpha = $2; YYACCEPT; }
	| System
          { alpha = $1; YYACCEPT; }
        | Equation
          { alpha = $1; YYACCEPT; }
        | Exp
          { alpha = $1; YYACCEPT; };

System_List : System
            { $$ = $1; }
	| System_List System
	    { $$ = $1; };

System : KW_system '[' ID_item ',' Parameter ',' System_Head ','
         Let_Equations ']'
        { node *a, *D, *idlists, *current;
          item *d4, *bound, *final, *main, *mainlist = (item *)0, 
               *d3, *d1, *d2, *f1;
          int i, j, k, array_dim;
          context_info *C2; 

	  /* These three must be done before calling control_domain */
          /* which frees the.dec.domain's */
          f1 = convert_decl2( alpha_node->the.sys.in, 1);
          f1 = add_to_ilist(f1, convert_decl2( alpha_node->the.sys.out, 0));
          f1 = add_to_ilist(f1, convert_decl2( alpha_node->the.sys.local, 0));
          f1 = add_to_ilist(f1, $9);

          mainlist = final = declare_indices();
	  final->next = Text("/* --inputs */");
          final = final->next;

          if (flag_loopNestForInputVariables)
          for (a = Ilist; a; a = a->next)
          {
	    D = get_decl(a,alpha_node);		/* get decl of input */
            /* dim of array is dim - dim of param */
            array_dim = D->the.decl.domain->the.dom.dim - G_dim;
	    idlists   = D->the.decl.domain->the.dom.index;

            /* compute loop */
            /* do before d3 so substitutions are right */
            C2 = control_domain(D->the.decl.domain, Context);
	    /* FREES D->the.decl.domain */

            /* d1 : a printf format string to print indices: %d,%d,... */
            d1 = Text("");
	    for (i=0; i<array_dim; i++)
	    { if (i==0) strcat(d1->the.text.string,"%d");
	      else      strcat(d1->the.text.string,",%d");
	    }

            /* d2 : a printf format string to print the output: %f or %d */
	    if (D->the.decl.type == realtype) d2 = Text("%f");
	    else                              d2 = Text("%d");

            /* d3 : the list of indices: i,j,... */
	    d3 = Hsep1(0, ",", id_list_n_sub(idlists, G_dim));

            /* d4 : the output name */
            d4 = Text("");
	    sprint_name(d4->the.text.string, a); 

            /* build loop body */
	    if (array_dim>0)
              if (!flag_quietProgram)
	        main = Henc(0, Text("printf(\""), Text(" );"),	/* array */
		         Hsep6(0, "",
                           Copy(d4),
			   Henc(0, Text("["), Text("]= "), d1),
			   d2,
			   Text("\\n\", "),
			   Copy(d3),
	                   Hsep3(0, "",
                              Text(", compute_"),
			      Copy(d4),
			      Henc(0, Text("("), Text(")"),
			         Copy(d3)
			      )
		           )
			 )
		       );
              else /* quiet prog */
                main =Hsep3(0, "",
                            Text(" compute_"),
                            Copy(d4),
                            Henc(0, Text("("), Text(");"),
                                 Copy(d3)
                                 )
                            );
            else /* scalar */
              if (!flag_quietProgram)
	        main = Henc(0, Text("printf(\""), Text(" );"),	/* scalar */
		          Hsep5(0, "",
                             Copy(d4),
			     Text(" = "),
			     d2,
			     Text("\\n\" "),
	                     Hsep3(0, "",
                                Text(", compute_"),
			        Copy(d4),
                                Henc(0, Text("("), Text(")"),
			           Text("")
			        )
		             )
			  )
	               );
              else /* quiet prog */
                main =Hsep3(0, "",
                            Text(" compute_"),
                            Copy(d4),
                            Henc(0, Text("("), Text(");"),
                                  Text("")
                                 )
                            );

            /* insert body into control code */
            *(C2->body) = main;
	    final->next = C2->code;
            final = C2->code;

            /* free context 
            C2->code = (item *) 0;
            free_node(C2->index);
            Domain_Free(C2->dom);
            free(C2); */

            /* restore the old context */
            index_restore(Context->index_stamp);
          }

	  final->next = Text("/* --outputs */");
          final = final->next;

          for (a = Olist; a; a = a->next)
          {
	    D = get_decl(a,alpha_node);		/* get decl of output */
            /* dim of array is dim - dim of param */
            array_dim = D->the.decl.domain->the.dom.dim - G_dim;
	    idlists   = D->the.decl.domain->the.dom.index;

            /* compute loop */
            /* do before d3 so substitutions are right */
            C2 = control_domain(D->the.decl.domain, Context);
	    /* FREES D->the.decl.domain */

            /* d1 : a printf format string to print indices: %d,%d,... */
            d1 = Text("");
	    for (i=0; i<array_dim; i++)
	    { if (i==0) strcat(d1->the.text.string,"%d");
	      else      strcat(d1->the.text.string,",%d");
	    }

            /* d2 : a printf format string to print the output: %f or %d */
	    if (D->the.decl.type == realtype) d2 = Text("%f");
	    else                              d2 = Text("%d");

            /* d3 : the list of indices: i,j,... */
	    d3 = Hsep1(0, ",", id_list_n_sub(idlists, G_dim));

            /* d4 : the output name */
            d4 = Text("");
	    sprint_name(d4->the.text.string, a); 

            /* build loop body */
	    if (array_dim>0)
              if (!flag_quietProgram)
	        main = Henc(0, Text("printf(\""), Text(" );"),	/* array */
	                 Hsep6(0, "",
                           Copy(d4),
			   Henc(0, Text("["), Text("]= "), d1),
			   d2,
			   Text("\\n\", "),
			   Copy(d3),
	                   Hsep3(0, "",
                              Text(", compute_"),
			      Copy(d4),
			      Henc(0, Text("("), Text(")"),
			         Copy(d3)
			      )
		           )
			 )
		       );
              else /* quiet prog */
                main =Henc(0, Text("printf(\""), Text(" );"), /* array */
                           Hsep2(0, "",
                                 Copy(d2),
                                 Hsep3(0, "",
                                       Text("\\n\", compute_"),
                                       Copy(d4),
                                       Henc(0, Text("("), Text(")"),
                                            Copy(d3)
                                            )
                                       )
                                 )
                      );
            else /* scalar */
              if (!flag_quietProgram)
	        main = Henc(0, Text("printf(\""), Text(" );"),	/* scalar */
	                 Hsep5(0, "",
                           Copy(d4),
			   Text(" = "),
			   d2,
			   Text("\\n\" "),
	                   Hsep3(0, "",
                              Text(", compute_"),
			      Copy(d4),
                              Henc(0, Text("("), Text(")"),
			         Text("")
			      )
		           )
			 )
	               );
              else /* quiet prog */
                 main =Henc(0, Text("printf(\""), Text(" );"),
                            Hsep2(0, "",
                                  Copy(d2),
                                  Hsep3(0, "",
                                        Text("\\n\", compute_"),
                                         Copy(d4),
                                        Henc(0, Text("("), Text(")"),
                                             Text("")
                                             )
                                        )
                                  )
                             );

            /* insert body into control code */
            *(C2->body) = main;
	    final->next = C2->code;
            final = C2->code;

            /* free context
            C2->code = (item *) 0;
            free_node(C2->index);
            Domain_Free(C2->dom);
            free(C2); */

            /* restore the old context */
            index_restore(Context->index_stamp);
          }

          $$ = Vsep7(0, "\n\n",
                  Henc(0, Text("/* system "), Text(" */"), $3),
                  Vsep9(0, "",
     Text(GREETING),
     Text("#include <stdlib.h>\n"),
     Text("#include <stdio.h>\n"),
     Text("#include <math.h>\n"),
     Text("typedef struct { int value;\n\t\t int computed; } intvar;"),
     Text("typedef struct { int value;\n\t\t int computed; } boolvar;"),
     Text("typedef struct { double value;\n\t\t int computed; } realvar;"),
     Text("double atof();"),
     Text("int    atoi();")
		  ),
/*		  Vsep11(0, "", */
		  Vsep10(0, "", 
     Text("#define min(x,y) ((x)<(y)?(x):(y))"),
     Text("#define max(x,y) ((x)>(y)?(x):(y))"),
/*     This is already defined in math.h */
/*     Text("#define INFINITY 0x7fffffff"), */
     Text("#define SHR(x,y) ((x)/(double)(1<<(y)))"),
     Text("#define SHL(x,y) ((x)*(double)(1<<(y)))"),
     Text("#define EXP(x,y) pow((x),(y))"),
     Text("#define TRUNCATE(x) ((int)(x))"),
     Text("#define CEILING(x) ((int)(ceil(x)))"),
     Text("#define FLOOR(x) ((int)(floor(x)))"),
     Text("#define ROUND(x) ((int)(rint(x)))"),
     Text("#define FLOAT(x) ((double)(x))")
                  ),
                  $5,			/* Parameter define */
                  $7,			/* Variable declarations */
		  Vsep(0, "\n\n",	/* input functions and predeclarations*/
                    f1			/* output and local functions */
                  ),
	          Vlis2(0, "",		/* main function */
                     Text("int main()"),
		     Venc(3, Text("{"), Text("}"),
                        Vsep1(0, "", mainlist)
                     )
		  )
	       );
	};

Parameter : Domain
	{   /* initialize the context */
            Context = (context_info *) malloc (sizeof(context_info));
            $$ = initialize_context($1, G_dim, G_val, Context);
        };

System_Head : Input_Decl ',' Output_Decl ',' Local_Decl
          { $$ = Vsep3(0, "\n\n", $1, $3, $5); };

Input_Decl : '{' {ilist_flag=1;} Decl_List {ilist_flag=0;} '}'
        { if ($3->the.list.first == (node *)0)
            $$ = Text("/* no input variables */");
          else
            $$ = Vsep3(0,"",
                    Text("/* input variables */\n"),
                    Text("char __s_[32];\n"),
                    Vsep(0, "", convert_decl($3,1))
                 );
          alpha_node->the.sys.in = $3;
        };

Output_Decl : '{' {olist_flag=1;} Decl_List {olist_flag=0;} '}'
        { if ($3->the.list.first == (node *)0)
            $$ = Text("/* no output variables */");
          else
            $$ = Vsep2(0, "",
		    Text("/* output variables */\n"),
		    Vsep(0, "\n", convert_decl($3,1))
                 );
          alpha_node->the.sys.out = $3;
        };

Local_Decl : '{' Decl_List '}'
        { if ($2->the.list.first == (node *)0)
            $$ = Text("/* no local variables */");
          else
            $$ = Vsep2(0,"",
                    Text("/* local variables */\n"),
                    Vsep(0, "", convert_decl($2,1))
                 );
          alpha_node->the.sys.local = $2;
        };

Let_Equations: '{' Equation_List '}'
        { $$ = Vsep2(0, "",
		  Text("/* --let equations */\n"),
		  Vsep1(0, "\n\n", $2)
               );
	}
|       KW_let '[' '{' Equation_List '}' ']'
	{ $$ = Vsep2(0, "",
		  Text("/* --let equations */\n"),
		  Vlis1(0, "\n", $4)
	       );
	}
|       KW_let '[' Equation_List ']'
	{ $$ = Vsep2(0, "",
		  Text("/* --let equations */\n"),
		  Vlis1(0, "\n", $3)
	       );
	};

Decl_List : Decl
        {  $$ = new_list($1); }

|       Decl_List ',' Decl
        {  $$ = add_to_list($1, $3); }

|       /* empty */
        {  $$ = new_list(0);};

Decl : KW_decl '[' ID ',' Data_Type ',' KW_scalar ']'
        {  $$ = new_node(decl);
           $$->the.decl.id = $3;
           $$->the.decl.type = $5;
           $$->the.decl.domain = (node *)0; }

|       KW_decl '[' ID ',' Data_Type ',' Domain ']'
        {  Polyhedron *P;
           node *tail;
           node *p;
           int i;

           if (ilist_flag)
           { /* creates a list for use in main body loop calculations */
             if (Ilist) {tail->next = $3; tail = $3;}
             else {Ilist = tail = $3;}
	   }

           if (olist_flag)
           { /* creates a list for use in main body loop calculations */
             if (Olist) {tail->next = $3; tail = $3;}
             else {Olist = tail = $3;}
	   }

           $$ = new_node(decl);
           $$->the.decl.id = $3;
           $$->the.decl.type = $5;
           $$->the.decl.domain = $7;
           P = node2domain($7);
           compute_W(P, Context->dom, $7->the.dom.index, Context->index,
                     &($$->the.decl.l), &($$->the.decl.w) );
           Domain_Free(P);

           /* Declare the indices */
           for (i=0, p=$7->the.dom.index->the.list.first ;
                i<($7->the.dom.dim-G_dim) ;
                i++, p= p->next ) {  
             mark_index(p, FREE);
           }

        };

Data_Type : KW_integer
        {  $$=inttype; }

|       KW_boolean
        {  $$=booltype; }

|       KW_real
        {  $$=realtype; };

/*-----------------------------------------------------------------*/
/* III. Equation and Expression Specifications                     */
/*-----------------------------------------------------------------*/

Equation_List : Equation
	{  $$ = $1; }

|	Equation_List ',' Equation
	{  $$ = add_to_ilist($1, $3); }

|	/* empty */
	{  $$ = (item *)0;};

Equation : KW_equation '[' ID { Eqn_Decl = get_decl($3,alpha_node);} ',' Exp ']'
	{ item *id, *idlist, *t1, *t2, *t3, *type, *contents;
	  int i, infinite, dim;
	  
	  id = Text("");
	  sprint_name(id->the.text.string,Eqn_Decl->the.decl.id);

          dim = Eqn_Decl->the.decl.domain->the.dom.dim - G_dim;

          t1 = Henc(0, Text("["), Text("]"), dim ? Text("%d") : Text(""));
          for (i=1; i<dim; i++)
            strcat(t1->the.henc.body->the.text.string,",%d");

	  if (Eqn_Decl->the.decl.type == realtype)
	    { type = Text("realvar ");
	      t2 = Text("atof");
              t3 = Text("double ");
	    }
	  else
	    { if (Eqn_Decl->the.decl.type == booltype) type = Text("boolvar ");
	      else                                     type = Text("intvar ");
	      t2 = Text("atoi");
	      t3 = Text("int ");
	    }
	  idlist = Hsep1(0, ",",
		      id_list_n(Eqn_Decl->the.decl.domain->the.dom.index,G_dim)
		   );
	  /* test for an infinite domain, requiring different processing */
          if (Eqn_Decl->the.decl.w) infinite=0; else infinite=1;

	  if (!infinite)
               contents = Henc(0, Text("\n     tmp->value = "), Text(""),
		             Hlis2(0, "", $6, Text(";"))
                          );
          else contents = Henc(0, Text("  tmp = "), Text(""),
			     Hlis2(0, "", $6, Text(";"))
                          );

	  $$ = create_body(type,t1,t2,t3,id,idlist,contents,
                           dim,infinite);
	  Eqn_ID=(node *)0;
	  $$->prec = 0;
	};

Exp_List : Exp
	{  $$ = $1; }

|	Exp_List ',' Exp
	{  $$ = add_to_ilist($1, $3); }

|	/* empty*/
	{  $$ = (item *)0;};

Push_Clear_Case : {$$=case_flag; case_flag=0;};

Exp :   KW_restrict '[' Domain ',' Push_Clear_Case Exp ']'
	{ item *tmp, *item3;
          item3 = Hsep1(0, "",
		     domain2C(Eqn_Decl->the.decl.domain->the.dom.index, $3)
		  );
	  tmp = Hsep2(3, " ? ",
                   Henc(2, Text("( "), Text(" ) "), item3),
		   Henc(2, Text("( "), Text(" ) : "), $6)
		);
	  /* flag was pushed on symbol stack and cleared for Exp */
	  case_flag = $5;	/* restore case flag */
	  if (case_flag) $$ = tmp;
	  else $$ = Vlis2(0, "",
		       tmp,
/* GCC does not support this kind of exit instruction */
/*                     Text("  ( printf(\"? restriction error\\n\"), exit(-1))") */
                       Text("  ( printf(\"? restriction error\\n\"))")
		    );
	  $$->prec = 0;}

|       KW_case '[' {case_flag = 1;} '{' Exp_List '}' {case_flag = 0;} ']'
	{ /* check the types of all the expressions; if they are not restricts,
	     then dont bother with them */
	  $$ = Vsep2(2, "",
		  Vsep1(2,"",$5),
/* GCC does not support this kind of exit instruction 
                  Text("  ( printf(\"? case error\\n\"), exit(-1))") */
		  Text("  ( printf(\"? case error\\n\"))")
	       );
	  $$->prec = 0;}

|       KW_var '[' ID  ']'
	{ item *name;
          Var_Decl = get_decl($3,alpha_node);
          name = Text("");
	  sprint_name(name->the.text.string,Var_Decl->the.decl.id);
	  $$ = Hsep3(0, "",
		  Text("compute_"),
                  Copy(name),
		  Henc(0, Text("("), Text(")"),
		     Hsep1(0, ",",
			id_list_n(Eqn_Decl->the.decl.domain->the.dom.index,
				 G_dim)
                     )
                  )
	       );
	  $$->prec = 10;}

|	KW_affine '[' KW_var '[' ID ']' ',' Matrix ']'
	{ item *name;
          Var_Decl = get_decl($5,alpha_node);
          name = Text("");
	  sprint_name(name->the.text.string,Var_Decl->the.decl.id);
	  $$ = Hsep3(0, "",
                  Text("compute_"),
                  Copy(name),
		  Henc(0, Text("("), Text(")"),
	             affine_list(Eqn_Decl->the.decl.domain->the.dom.index,
                                    $8,G_dim,1)
		  )
	       );
	  $$->prec = 7;}

|       Constant
        {  $$ = $1; }

|       KW_affine '[' Constant ',' Matrix ']'
        {  $$ = $3; }

|	KW_binop '[' KW_add ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " + ", check_prec($5,5), check_prec($7,5));
	    $$->prec = 5;}

|	KW_binop '[' KW_sub ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " - ", check_prec($5,5), check_prec($7,5));
	    $$->prec = 5;}

|	KW_binop '[' KW_mul ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " * ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_div ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " / ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_idiv ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " / ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_mod ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " % ", check_prec($5,6), check_prec($7,6));
	    $$->prec = 6;}

|	KW_binop '[' KW_eq ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " == ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_le ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " <= ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_lt ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " < ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_gt ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " > ", check_prec($5,4),check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_ge ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " >= ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_ne ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " <> ", check_prec($5,4), check_prec($7,4));
	    $$->prec = 4;}

|	KW_binop '[' KW_or ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " || ", check_prec($5,1), check_prec($7,1));
	    $$->prec = 1;}

|	KW_binop '[' KW_xor ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " != ", check_prec($5,2), check_prec($7,2));
	    $$->prec = 2;}

|	KW_binop '[' KW_and ',' Exp ',' Exp ']'
	{   $$ = Hsep2(0, " && ", check_prec($5,3), check_prec($7,3));
	    $$->prec = 3;}

|       KW_binop '[' KW_min ',' Exp ',' Exp ']'
        {   $$ = Henc(0, Text("min("), Text(")"),
                    Hsep2(0, ", ", check_prec($5,0), check_prec($7,0))
                 );
            $$->prec = 8;}

|       KW_binop '[' KW_max ',' Exp ',' Exp ']'
        {   $$ = Henc(0, Text("max("), Text(")"),
                    Hsep2(0, ", ", check_prec($5,0), check_prec($7,0))
                 );
            $$->prec = 8;}

|	KW_unop '[' KW_neg ',' Exp ']'
	{   $$ = Hsep2(0, "", new_text("-"), check_prec($5,7));
	    $$->prec = 7;}

|	KW_unop '[' KW_sqrt ',' Exp ']'
	{   $$ = Henc(0, Text("sqrt("), Text(")"), check_prec($5,0));
	    $$->prec = 0;}

|	KW_unop '[' KW_not ',' Exp ']'
	{   $$ = Hsep2(0,"",new_text("!"), check_prec($5,7));
	    $$->prec = 7;}

|       KW_call '[' ID ',' '{' Exp_List '}' ']'
        {   item *name;
            name = Text($3->the.id.name);
            $$ = Hsep2(0, "", Copy(name),
                       Henc(0, Text("("), Text(")"), Hsep1(0,",",$6)));
        }

|	KW_if '[' Exp ',' Exp ',' Exp ']'
	{   $$ = Hsep5(4, " ",
		    Henc(0,Text("("),Text(")"), $3),
		    Text("?"),
		    Henc(0,Text("("),Text(")"), $5),
		    Text(":"),
		    Henc(0,Text("("),Text(")"), $7)
		 );
	    $$->prec = 0;};

Constant: KW_const '[' NUMBER ']'
        {  $$ = Number($3);
           $$->prec = 10;
        }

|       KW_const '[' KW_pos_infinity ']'
        {  $$ = Text("INFINITY");
           $$->prec = 10;
        }

|       KW_const '[' KW_neg_infinity ']'
        {  $$ = Text("-INFINITY");
           $$->prec = 10;
        }

|       KW_const '[' KW_true ']'
        {  $$ = Number(1);
           $$->prec = 10;
        }

|       KW_const '[' KW_false ']'
        {  $$ = Number(0);
           $$->prec = 10;
        }

|       KW_const '[' REAL  ']'
        {  $$ = Hsep2(0,".",Number($3->the.rconst.value),
                            Number($3->the.rconst.fraction));
           $$->prec = 10;
           free_node($3);
	}
|	KW_const '[' KW_matrix '[' NUMBER ',' NUMBER {V_Save=$7;} ','
		'{' ID_List '}' ',' '{' Number_List_List '}' ']' ']'
	{  $$ = Henc(0, Text("("), Text(")"),
	             affine_list($11,$15,0,1)
		  );
	   free_node($11); free_node($15);
	};

/*-----------------------------------------------------------------*/
/* IV. Domain Specifications                                       */
/*       -- build and return a node tree for a domain              */
/*-----------------------------------------------------------------*/

Domain : KW_domain '[' NUMBER ',' '{' ID_List '}' 
        {  ID_List_Save = $6; V_Save = $3+2; }
        ',' '{' Pol_List '}' ']'
	  { $$ = new_node(dom);
	    $$->the.dom.dim = $3;
	    $$->the.dom.index = $6;
	    $$->the.dom.pol = $11;
	};

ID_List : ID
	{  $$ = new_list($1); }

|	ID_List ',' ID
	{  $$ = add_to_list($1, $3); }

|	/* empty */
	{  $$ = new_list(0) ;};

Pol_List : Pol
	{  $$ = new_list($1); }

|	Pol_List ',' Pol
	{  $$ = add_to_list($1, $3); }

|	/* empty */
	{  $$ = new_list(0);};

Pol : KW_pol '[' NUMBER ',' NUMBER ',' NUMBER ',' NUMBER ','
     '{' Number_List_List '}' ',' '{' Number_List_List '}' ']'
	{  $$ = new_node(pol);
           $$->the.pol.nb_constraints = $3;
           $$->the.pol.nb_equations = $7;
           $$->the.pol.constraints = $12;
	   if ($3 != $12->the.list.count)
              yyerror("Polyhedron nb_constraints doesn't agree.");
           free_node($16);
        };

/*-----------------------------------------------------------------*/
/* V.  Matrix Specifications                                       */
/*  -- build and return a node tree for a list of list of integers */
/*-----------------------------------------------------------------*/

Matrix : KW_matrix '[' NUMBER ',' NUMBER ',' '{' ID_List '}'
        { V_Save = $5; }
        ',' '{' Number_List_List '}' ']'
        { $$ = $13; free_node($8); };

Number_List : NUMBER
        {  I_Save = 0;
           $$ = new_node(vec);
           $$->the.vec.dim = V_Save;
           if (I_Save >= V_Save) yyerror("Vector has too many elements");
           else
           {  $$->the.vec.val = (int *)malloc(V_Save * sizeof(int));
              $$->the.vec.val[0] = $1; I_Save++; }
        }

|       Number_List ',' NUMBER
        {  $$ = $1;
           if (I_Save >= V_Save) yyerror("Vector has too many elements");
           else {  $$->the.vec.val[I_Save] = $3; I_Save++; }
        }

|       /* empty */
        {  $$ = new_node(vec);
           $$->the.vec.dim = 0;
           $$->the.vec.val = (int *) 0; };

Number_List_List : '{' Number_List '}'
        {  $$ = new_list($2); }

|       Number_List_List ',' '{' Number_List '}'
        {  $$ = add_to_list($1, $4); }

|       /* empty */
        {  $$ = new_list(0);};

%%
#include "lex.c"

/* DEFINED PREVIOUSLY             */
/* extern  FILE    *yyin, *yyout; */
/* extern  int     lineNb;        */
/* extern  item    *alpha;        */
FILE *ref = 0;		/* cross reference file */

int main(argc, argv)
int argc;
char *argv[];
{ int status, arg, i;

  yydebug = 0;
  yyout = stdout;
  yyin = stdin;
  /* malloc_debug(2); */
  /* malloc_verify(); */

  arg=1;
  while (arg < argc)
  {  if (*argv[arg]=='-')
     switch (argv[arg][1])
     {  case 'i':       /* input */
          arg++;
          yyin = fopen(argv[arg],"r");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
	  }
          break;
        case 'I':       /* input */
          arg++;
          yyin = fdopen(atoi(argv[arg]),"r");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
          }
          break;
        case 'o':       /* output */
          arg++;
          yyout = fopen(argv[arg],"w");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
          }
          break;
        case 'O':       /* output */
          arg++;
          yyout = fdopen(atoi(argv[arg]),"w");
          if (!yyin)
          {  fprintf(stderr, "? Could not open %s.\n", argv[arg]);
             exit(1);
          }
          break;
        case 'd':       /* debug */
          yydebug = 1;
          break;
        case 'g':       /* debug for the resulting program */
          begdbg[0]='\0';
          enddbg[0]='\0';
          break;
        case 'p':
          arg++; i=0;
          G_val = (int *)malloc(12*sizeof(int));
          while (arg<argc && isdigit(*argv[arg]))
          { G_val[i] = atoi(argv[arg]);
            arg++; i++;
          }
          G_dim = i;
          arg--;
          break;
        case 's':      /* program for signal */
          flag_forSignal = 1;
          break;
        case 'q':      /* program with no prompt */
          if(!flag_loopNestForInputVariables) {
            fprintf(stderr,
              "? the -q switch is not available with the -L switch\n");
            exit(1);
          }
          flag_quietProgram = 1;
          break;
        case 'L':
          if(flag_quietProgram) {
            fprintf(stderr,
               "? the -L switch is not available with the -q switch\n");
            exit(1);
          }
          flag_loopNestForInputVariables = 0;
          break;
        default:
          fprintf(stderr, "? unknown switch %s\n", argv[arg]);
     }
     arg++;
  }

  alpha_node = new_node(sys);
  lineNb = 1;
  status = yyparse();
  if (status==1) /* parsing failed */ exit(1);
  print_item(alpha);
  fputc('\n', yyout);
  return 0;
}

yywrap()
{ return(1); }

yyerror(s)
char *s;
{  fprintf(stderr,"? line %d: %s\n", lineNb, s);
}
